// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: features.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_features_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_features_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_features_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_features_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_features_2eproto;
class BatchFeatures;
struct BatchFeaturesDefaultTypeInternal;
extern BatchFeaturesDefaultTypeInternal _BatchFeatures_default_instance_;
class Feature;
struct FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
class Features;
struct FeaturesDefaultTypeInternal;
extern FeaturesDefaultTypeInternal _Features_default_instance_;
class Features_ValueEntry_DoNotUse;
struct Features_ValueEntry_DoNotUseDefaultTypeInternal;
extern Features_ValueEntry_DoNotUseDefaultTypeInternal _Features_ValueEntry_DoNotUse_default_instance_;
class FloatList;
struct FloatListDefaultTypeInternal;
extern FloatListDefaultTypeInternal _FloatList_default_instance_;
class IntFloat;
struct IntFloatDefaultTypeInternal;
extern IntFloatDefaultTypeInternal _IntFloat_default_instance_;
class IntFloatList;
struct IntFloatListDefaultTypeInternal;
extern IntFloatListDefaultTypeInternal _IntFloatList_default_instance_;
class IntInt;
struct IntIntDefaultTypeInternal;
extern IntIntDefaultTypeInternal _IntInt_default_instance_;
class IntIntList;
struct IntIntListDefaultTypeInternal;
extern IntIntListDefaultTypeInternal _IntIntList_default_instance_;
class IntList;
struct IntListDefaultTypeInternal;
extern IntListDefaultTypeInternal _IntList_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemAction;
struct ItemActionDefaultTypeInternal;
extern ItemActionDefaultTypeInternal _ItemAction_default_instance_;
class ItemActionList;
struct ItemActionListDefaultTypeInternal;
extern ItemActionListDefaultTypeInternal _ItemActionList_default_instance_;
class LongFloat;
struct LongFloatDefaultTypeInternal;
extern LongFloatDefaultTypeInternal _LongFloat_default_instance_;
class LongFloatList;
struct LongFloatListDefaultTypeInternal;
extern LongFloatListDefaultTypeInternal _LongFloatList_default_instance_;
class LongInt;
struct LongIntDefaultTypeInternal;
extern LongIntDefaultTypeInternal _LongInt_default_instance_;
class LongIntList;
struct LongIntListDefaultTypeInternal;
extern LongIntListDefaultTypeInternal _LongIntList_default_instance_;
class LongList;
struct LongListDefaultTypeInternal;
extern LongListDefaultTypeInternal _LongList_default_instance_;
class RTUserActionList;
struct RTUserActionListDefaultTypeInternal;
extern RTUserActionListDefaultTypeInternal _RTUserActionList_default_instance_;
class RTUserActionList_ItemsEntry_DoNotUse;
struct RTUserActionList_ItemsEntry_DoNotUseDefaultTypeInternal;
extern RTUserActionList_ItemsEntry_DoNotUseDefaultTypeInternal _RTUserActionList_ItemsEntry_DoNotUse_default_instance_;
class StrFloat;
struct StrFloatDefaultTypeInternal;
extern StrFloatDefaultTypeInternal _StrFloat_default_instance_;
class StrFloatList;
struct StrFloatListDefaultTypeInternal;
extern StrFloatListDefaultTypeInternal _StrFloatList_default_instance_;
class StrInt;
struct StrIntDefaultTypeInternal;
extern StrIntDefaultTypeInternal _StrInt_default_instance_;
class StrIntList;
struct StrIntListDefaultTypeInternal;
extern StrIntListDefaultTypeInternal _StrIntList_default_instance_;
class StrList;
struct StrListDefaultTypeInternal;
extern StrListDefaultTypeInternal _StrList_default_instance_;
class UserAction;
struct UserActionDefaultTypeInternal;
extern UserActionDefaultTypeInternal _UserAction_default_instance_;
class UserActionList;
struct UserActionListDefaultTypeInternal;
extern UserActionListDefaultTypeInternal _UserActionList_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BatchFeatures* Arena::CreateMaybeMessage<::BatchFeatures>(Arena*);
template<> ::Feature* Arena::CreateMaybeMessage<::Feature>(Arena*);
template<> ::Features* Arena::CreateMaybeMessage<::Features>(Arena*);
template<> ::Features_ValueEntry_DoNotUse* Arena::CreateMaybeMessage<::Features_ValueEntry_DoNotUse>(Arena*);
template<> ::FloatList* Arena::CreateMaybeMessage<::FloatList>(Arena*);
template<> ::IntFloat* Arena::CreateMaybeMessage<::IntFloat>(Arena*);
template<> ::IntFloatList* Arena::CreateMaybeMessage<::IntFloatList>(Arena*);
template<> ::IntInt* Arena::CreateMaybeMessage<::IntInt>(Arena*);
template<> ::IntIntList* Arena::CreateMaybeMessage<::IntIntList>(Arena*);
template<> ::IntList* Arena::CreateMaybeMessage<::IntList>(Arena*);
template<> ::Item* Arena::CreateMaybeMessage<::Item>(Arena*);
template<> ::ItemAction* Arena::CreateMaybeMessage<::ItemAction>(Arena*);
template<> ::ItemActionList* Arena::CreateMaybeMessage<::ItemActionList>(Arena*);
template<> ::LongFloat* Arena::CreateMaybeMessage<::LongFloat>(Arena*);
template<> ::LongFloatList* Arena::CreateMaybeMessage<::LongFloatList>(Arena*);
template<> ::LongInt* Arena::CreateMaybeMessage<::LongInt>(Arena*);
template<> ::LongIntList* Arena::CreateMaybeMessage<::LongIntList>(Arena*);
template<> ::LongList* Arena::CreateMaybeMessage<::LongList>(Arena*);
template<> ::RTUserActionList* Arena::CreateMaybeMessage<::RTUserActionList>(Arena*);
template<> ::RTUserActionList_ItemsEntry_DoNotUse* Arena::CreateMaybeMessage<::RTUserActionList_ItemsEntry_DoNotUse>(Arena*);
template<> ::StrFloat* Arena::CreateMaybeMessage<::StrFloat>(Arena*);
template<> ::StrFloatList* Arena::CreateMaybeMessage<::StrFloatList>(Arena*);
template<> ::StrInt* Arena::CreateMaybeMessage<::StrInt>(Arena*);
template<> ::StrIntList* Arena::CreateMaybeMessage<::StrIntList>(Arena*);
template<> ::StrList* Arena::CreateMaybeMessage<::StrList>(Arena*);
template<> ::UserAction* Arena::CreateMaybeMessage<::UserAction>(Arena*);
template<> ::UserActionList* Arena::CreateMaybeMessage<::UserActionList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class BatchFeatures final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BatchFeatures) */ {
 public:
  inline BatchFeatures() : BatchFeatures(nullptr) {}
  ~BatchFeatures() override;
  explicit PROTOBUF_CONSTEXPR BatchFeatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchFeatures(const BatchFeatures& from);
  BatchFeatures(BatchFeatures&& from) noexcept
    : BatchFeatures() {
    *this = ::std::move(from);
  }

  inline BatchFeatures& operator=(const BatchFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchFeatures& operator=(BatchFeatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchFeatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchFeatures* internal_default_instance() {
    return reinterpret_cast<const BatchFeatures*>(
               &_BatchFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BatchFeatures& a, BatchFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchFeatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchFeatures>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchFeatures& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchFeatures& from) {
    BatchFeatures::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchFeatures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BatchFeatures";
  }
  protected:
  explicit BatchFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .Features value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::Features* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Features >*
      mutable_value();
  private:
  const ::Features& _internal_value(int index) const;
  ::Features* _internal_add_value();
  public:
  const ::Features& value(int index) const;
  ::Features* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Features >&
      value() const;

  // @@protoc_insertion_point(class_scope:BatchFeatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Features > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class Features_ValueEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Features_ValueEntry_DoNotUse, 
    std::string, ::Feature,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Features_ValueEntry_DoNotUse, 
    std::string, ::Feature,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Features_ValueEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Features_ValueEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Features_ValueEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Features_ValueEntry_DoNotUse& other);
  static const Features_ValueEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Features_ValueEntry_DoNotUse*>(&_Features_ValueEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Features.ValueEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_features_2eproto;
};

// -------------------------------------------------------------------

class Features final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Features) */ {
 public:
  inline Features() : Features(nullptr) {}
  ~Features() override;
  explicit PROTOBUF_CONSTEXPR Features(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Features(const Features& from);
  Features(Features&& from) noexcept
    : Features() {
    *this = ::std::move(from);
  }

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }
  inline Features& operator=(Features&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Features& default_instance() {
    return *internal_default_instance();
  }
  static inline const Features* internal_default_instance() {
    return reinterpret_cast<const Features*>(
               &_Features_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Features& a, Features& b) {
    a.Swap(&b);
  }
  inline void Swap(Features* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Features* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Features* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Features>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Features& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Features& from) {
    Features::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Features* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Features";
  }
  protected:
  explicit Features(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // map<string, .Feature> value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >&
      _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >*
      _internal_mutable_value();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >*
      mutable_value();

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:Features)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Features_ValueEntry_DoNotUse,
        std::string, ::Feature,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class Feature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Feature) */ {
 public:
  inline Feature() : Feature(nullptr) {}
  ~Feature() override;
  explicit PROTOBUF_CONSTEXPR Feature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Feature(const Feature& from);
  Feature(Feature&& from) noexcept
    : Feature() {
    *this = ::std::move(from);
  }

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Feature& operator=(Feature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Feature& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kStrIntList = 1,
    kStrFloatList = 2,
    kIntIntList = 3,
    kIntFloatList = 4,
    kLongIntList = 5,
    kLongFloatList = 6,
    kStrList = 7,
    kIntList = 8,
    kLongList = 9,
    kFloatList = 10,
    kUserActionList = 11,
    kRtUserActionList = 12,
    kItemActionList = 13,
    kStrValue = 14,
    kFloatValue = 15,
    kIntValue = 16,
    kLongValue = 17,
    KIND_NOT_SET = 0,
  };

  static inline const Feature* internal_default_instance() {
    return reinterpret_cast<const Feature*>(
               &_Feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Feature& a, Feature& b) {
    a.Swap(&b);
  }
  inline void Swap(Feature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Feature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Feature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Feature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Feature& from) {
    Feature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Feature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Feature";
  }
  protected:
  explicit Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrIntListFieldNumber = 1,
    kStrFloatListFieldNumber = 2,
    kIntIntListFieldNumber = 3,
    kIntFloatListFieldNumber = 4,
    kLongIntListFieldNumber = 5,
    kLongFloatListFieldNumber = 6,
    kStrListFieldNumber = 7,
    kIntListFieldNumber = 8,
    kLongListFieldNumber = 9,
    kFloatListFieldNumber = 10,
    kUserActionListFieldNumber = 11,
    kRtUserActionListFieldNumber = 12,
    kItemActionListFieldNumber = 13,
    kStrValueFieldNumber = 14,
    kFloatValueFieldNumber = 15,
    kIntValueFieldNumber = 16,
    kLongValueFieldNumber = 17,
  };
  // .StrIntList str_int_list = 1;
  bool has_str_int_list() const;
  private:
  bool _internal_has_str_int_list() const;
  public:
  void clear_str_int_list();
  const ::StrIntList& str_int_list() const;
  PROTOBUF_NODISCARD ::StrIntList* release_str_int_list();
  ::StrIntList* mutable_str_int_list();
  void set_allocated_str_int_list(::StrIntList* str_int_list);
  private:
  const ::StrIntList& _internal_str_int_list() const;
  ::StrIntList* _internal_mutable_str_int_list();
  public:
  void unsafe_arena_set_allocated_str_int_list(
      ::StrIntList* str_int_list);
  ::StrIntList* unsafe_arena_release_str_int_list();

  // .StrFloatList str_float_list = 2;
  bool has_str_float_list() const;
  private:
  bool _internal_has_str_float_list() const;
  public:
  void clear_str_float_list();
  const ::StrFloatList& str_float_list() const;
  PROTOBUF_NODISCARD ::StrFloatList* release_str_float_list();
  ::StrFloatList* mutable_str_float_list();
  void set_allocated_str_float_list(::StrFloatList* str_float_list);
  private:
  const ::StrFloatList& _internal_str_float_list() const;
  ::StrFloatList* _internal_mutable_str_float_list();
  public:
  void unsafe_arena_set_allocated_str_float_list(
      ::StrFloatList* str_float_list);
  ::StrFloatList* unsafe_arena_release_str_float_list();

  // .IntIntList int_int_list = 3;
  bool has_int_int_list() const;
  private:
  bool _internal_has_int_int_list() const;
  public:
  void clear_int_int_list();
  const ::IntIntList& int_int_list() const;
  PROTOBUF_NODISCARD ::IntIntList* release_int_int_list();
  ::IntIntList* mutable_int_int_list();
  void set_allocated_int_int_list(::IntIntList* int_int_list);
  private:
  const ::IntIntList& _internal_int_int_list() const;
  ::IntIntList* _internal_mutable_int_int_list();
  public:
  void unsafe_arena_set_allocated_int_int_list(
      ::IntIntList* int_int_list);
  ::IntIntList* unsafe_arena_release_int_int_list();

  // .IntFloatList int_float_list = 4;
  bool has_int_float_list() const;
  private:
  bool _internal_has_int_float_list() const;
  public:
  void clear_int_float_list();
  const ::IntFloatList& int_float_list() const;
  PROTOBUF_NODISCARD ::IntFloatList* release_int_float_list();
  ::IntFloatList* mutable_int_float_list();
  void set_allocated_int_float_list(::IntFloatList* int_float_list);
  private:
  const ::IntFloatList& _internal_int_float_list() const;
  ::IntFloatList* _internal_mutable_int_float_list();
  public:
  void unsafe_arena_set_allocated_int_float_list(
      ::IntFloatList* int_float_list);
  ::IntFloatList* unsafe_arena_release_int_float_list();

  // .LongIntList long_int_list = 5;
  bool has_long_int_list() const;
  private:
  bool _internal_has_long_int_list() const;
  public:
  void clear_long_int_list();
  const ::LongIntList& long_int_list() const;
  PROTOBUF_NODISCARD ::LongIntList* release_long_int_list();
  ::LongIntList* mutable_long_int_list();
  void set_allocated_long_int_list(::LongIntList* long_int_list);
  private:
  const ::LongIntList& _internal_long_int_list() const;
  ::LongIntList* _internal_mutable_long_int_list();
  public:
  void unsafe_arena_set_allocated_long_int_list(
      ::LongIntList* long_int_list);
  ::LongIntList* unsafe_arena_release_long_int_list();

  // .LongFloatList long_float_list = 6;
  bool has_long_float_list() const;
  private:
  bool _internal_has_long_float_list() const;
  public:
  void clear_long_float_list();
  const ::LongFloatList& long_float_list() const;
  PROTOBUF_NODISCARD ::LongFloatList* release_long_float_list();
  ::LongFloatList* mutable_long_float_list();
  void set_allocated_long_float_list(::LongFloatList* long_float_list);
  private:
  const ::LongFloatList& _internal_long_float_list() const;
  ::LongFloatList* _internal_mutable_long_float_list();
  public:
  void unsafe_arena_set_allocated_long_float_list(
      ::LongFloatList* long_float_list);
  ::LongFloatList* unsafe_arena_release_long_float_list();

  // .StrList str_list = 7;
  bool has_str_list() const;
  private:
  bool _internal_has_str_list() const;
  public:
  void clear_str_list();
  const ::StrList& str_list() const;
  PROTOBUF_NODISCARD ::StrList* release_str_list();
  ::StrList* mutable_str_list();
  void set_allocated_str_list(::StrList* str_list);
  private:
  const ::StrList& _internal_str_list() const;
  ::StrList* _internal_mutable_str_list();
  public:
  void unsafe_arena_set_allocated_str_list(
      ::StrList* str_list);
  ::StrList* unsafe_arena_release_str_list();

  // .IntList int_list = 8;
  bool has_int_list() const;
  private:
  bool _internal_has_int_list() const;
  public:
  void clear_int_list();
  const ::IntList& int_list() const;
  PROTOBUF_NODISCARD ::IntList* release_int_list();
  ::IntList* mutable_int_list();
  void set_allocated_int_list(::IntList* int_list);
  private:
  const ::IntList& _internal_int_list() const;
  ::IntList* _internal_mutable_int_list();
  public:
  void unsafe_arena_set_allocated_int_list(
      ::IntList* int_list);
  ::IntList* unsafe_arena_release_int_list();

  // .LongList long_list = 9;
  bool has_long_list() const;
  private:
  bool _internal_has_long_list() const;
  public:
  void clear_long_list();
  const ::LongList& long_list() const;
  PROTOBUF_NODISCARD ::LongList* release_long_list();
  ::LongList* mutable_long_list();
  void set_allocated_long_list(::LongList* long_list);
  private:
  const ::LongList& _internal_long_list() const;
  ::LongList* _internal_mutable_long_list();
  public:
  void unsafe_arena_set_allocated_long_list(
      ::LongList* long_list);
  ::LongList* unsafe_arena_release_long_list();

  // .FloatList float_list = 10;
  bool has_float_list() const;
  private:
  bool _internal_has_float_list() const;
  public:
  void clear_float_list();
  const ::FloatList& float_list() const;
  PROTOBUF_NODISCARD ::FloatList* release_float_list();
  ::FloatList* mutable_float_list();
  void set_allocated_float_list(::FloatList* float_list);
  private:
  const ::FloatList& _internal_float_list() const;
  ::FloatList* _internal_mutable_float_list();
  public:
  void unsafe_arena_set_allocated_float_list(
      ::FloatList* float_list);
  ::FloatList* unsafe_arena_release_float_list();

  // .UserActionList user_action_list = 11;
  bool has_user_action_list() const;
  private:
  bool _internal_has_user_action_list() const;
  public:
  void clear_user_action_list();
  const ::UserActionList& user_action_list() const;
  PROTOBUF_NODISCARD ::UserActionList* release_user_action_list();
  ::UserActionList* mutable_user_action_list();
  void set_allocated_user_action_list(::UserActionList* user_action_list);
  private:
  const ::UserActionList& _internal_user_action_list() const;
  ::UserActionList* _internal_mutable_user_action_list();
  public:
  void unsafe_arena_set_allocated_user_action_list(
      ::UserActionList* user_action_list);
  ::UserActionList* unsafe_arena_release_user_action_list();

  // .RTUserActionList rt_user_action_list = 12;
  bool has_rt_user_action_list() const;
  private:
  bool _internal_has_rt_user_action_list() const;
  public:
  void clear_rt_user_action_list();
  const ::RTUserActionList& rt_user_action_list() const;
  PROTOBUF_NODISCARD ::RTUserActionList* release_rt_user_action_list();
  ::RTUserActionList* mutable_rt_user_action_list();
  void set_allocated_rt_user_action_list(::RTUserActionList* rt_user_action_list);
  private:
  const ::RTUserActionList& _internal_rt_user_action_list() const;
  ::RTUserActionList* _internal_mutable_rt_user_action_list();
  public:
  void unsafe_arena_set_allocated_rt_user_action_list(
      ::RTUserActionList* rt_user_action_list);
  ::RTUserActionList* unsafe_arena_release_rt_user_action_list();

  // .ItemActionList item_action_list = 13;
  bool has_item_action_list() const;
  private:
  bool _internal_has_item_action_list() const;
  public:
  void clear_item_action_list();
  const ::ItemActionList& item_action_list() const;
  PROTOBUF_NODISCARD ::ItemActionList* release_item_action_list();
  ::ItemActionList* mutable_item_action_list();
  void set_allocated_item_action_list(::ItemActionList* item_action_list);
  private:
  const ::ItemActionList& _internal_item_action_list() const;
  ::ItemActionList* _internal_mutable_item_action_list();
  public:
  void unsafe_arena_set_allocated_item_action_list(
      ::ItemActionList* item_action_list);
  ::ItemActionList* unsafe_arena_release_item_action_list();

  // string str_value = 14;
  bool has_str_value() const;
  private:
  bool _internal_has_str_value() const;
  public:
  void clear_str_value();
  const std::string& str_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_value();
  PROTOBUF_NODISCARD std::string* release_str_value();
  void set_allocated_str_value(std::string* str_value);
  private:
  const std::string& _internal_str_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_value(const std::string& value);
  std::string* _internal_mutable_str_value();
  public:

  // float float_value = 15;
  bool has_float_value() const;
  private:
  bool _internal_has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);
  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);
  public:

  // int32 int_value = 16;
  bool has_int_value() const;
  private:
  bool _internal_has_int_value() const;
  public:
  void clear_int_value();
  int32_t int_value() const;
  void set_int_value(int32_t value);
  private:
  int32_t _internal_int_value() const;
  void _internal_set_int_value(int32_t value);
  public:

  // int64 long_value = 17;
  bool has_long_value() const;
  private:
  bool _internal_has_long_value() const;
  public:
  void clear_long_value();
  int64_t long_value() const;
  void set_long_value(int64_t value);
  private:
  int64_t _internal_long_value() const;
  void _internal_set_long_value(int64_t value);
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:Feature)
 private:
  class _Internal;
  void set_has_str_int_list();
  void set_has_str_float_list();
  void set_has_int_int_list();
  void set_has_int_float_list();
  void set_has_long_int_list();
  void set_has_long_float_list();
  void set_has_str_list();
  void set_has_int_list();
  void set_has_long_list();
  void set_has_float_list();
  void set_has_user_action_list();
  void set_has_rt_user_action_list();
  void set_has_item_action_list();
  void set_has_str_value();
  void set_has_float_value();
  void set_has_int_value();
  void set_has_long_value();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::StrIntList* str_int_list_;
      ::StrFloatList* str_float_list_;
      ::IntIntList* int_int_list_;
      ::IntFloatList* int_float_list_;
      ::LongIntList* long_int_list_;
      ::LongFloatList* long_float_list_;
      ::StrList* str_list_;
      ::IntList* int_list_;
      ::LongList* long_list_;
      ::FloatList* float_list_;
      ::UserActionList* user_action_list_;
      ::RTUserActionList* rt_user_action_list_;
      ::ItemActionList* item_action_list_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_value_;
      float float_value_;
      int32_t int_value_;
      int64_t long_value_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class UserAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserAction) */ {
 public:
  inline UserAction() : UserAction(nullptr) {}
  ~UserAction() override;
  explicit PROTOBUF_CONSTEXPR UserAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserAction(const UserAction& from);
  UserAction(UserAction&& from) noexcept
    : UserAction() {
    *this = ::std::move(from);
  }

  inline UserAction& operator=(const UserAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAction& operator=(UserAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAction* internal_default_instance() {
    return reinterpret_cast<const UserAction*>(
               &_UserAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserAction& a, UserAction& b) {
    a.Swap(&b);
  }
  inline void Swap(UserAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserAction& from) {
    UserAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserAction";
  }
  protected:
  explicit UserAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kFirstTimeFieldNumber = 2,
    kLastSecondTimeFieldNumber = 3,
    kLastTimeFieldNumber = 4,
    kCntFieldNumber = 5,
  };
  // string item_id = 1;
  void clear_item_id();
  const std::string& item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // int64 first_time = 2;
  void clear_first_time();
  int64_t first_time() const;
  void set_first_time(int64_t value);
  private:
  int64_t _internal_first_time() const;
  void _internal_set_first_time(int64_t value);
  public:

  // int64 last_second_time = 3;
  void clear_last_second_time();
  int64_t last_second_time() const;
  void set_last_second_time(int64_t value);
  private:
  int64_t _internal_last_second_time() const;
  void _internal_set_last_second_time(int64_t value);
  public:

  // int64 last_time = 4;
  void clear_last_time();
  int64_t last_time() const;
  void set_last_time(int64_t value);
  private:
  int64_t _internal_last_time() const;
  void _internal_set_last_time(int64_t value);
  public:

  // int32 cnt = 5;
  void clear_cnt();
  int32_t cnt() const;
  void set_cnt(int32_t value);
  private:
  int32_t _internal_cnt() const;
  void _internal_set_cnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    int64_t first_time_;
    int64_t last_second_time_;
    int64_t last_time_;
    int32_t cnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class StrInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StrInt) */ {
 public:
  inline StrInt() : StrInt(nullptr) {}
  ~StrInt() override;
  explicit PROTOBUF_CONSTEXPR StrInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrInt(const StrInt& from);
  StrInt(StrInt&& from) noexcept
    : StrInt() {
    *this = ::std::move(from);
  }

  inline StrInt& operator=(const StrInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrInt& operator=(StrInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrInt* internal_default_instance() {
    return reinterpret_cast<const StrInt*>(
               &_StrInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StrInt& a, StrInt& b) {
    a.Swap(&b);
  }
  inline void Swap(StrInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrInt& from) {
    StrInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StrInt";
  }
  protected:
  explicit StrInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StrInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class StrFloat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StrFloat) */ {
 public:
  inline StrFloat() : StrFloat(nullptr) {}
  ~StrFloat() override;
  explicit PROTOBUF_CONSTEXPR StrFloat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrFloat(const StrFloat& from);
  StrFloat(StrFloat&& from) noexcept
    : StrFloat() {
    *this = ::std::move(from);
  }

  inline StrFloat& operator=(const StrFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrFloat& operator=(StrFloat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrFloat& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrFloat* internal_default_instance() {
    return reinterpret_cast<const StrFloat*>(
               &_StrFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StrFloat& a, StrFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(StrFloat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrFloat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrFloat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrFloat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrFloat& from) {
    StrFloat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrFloat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StrFloat";
  }
  protected:
  explicit StrFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // float value = 2;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:StrFloat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class IntInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntInt) */ {
 public:
  inline IntInt() : IntInt(nullptr) {}
  ~IntInt() override;
  explicit PROTOBUF_CONSTEXPR IntInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntInt(const IntInt& from);
  IntInt(IntInt&& from) noexcept
    : IntInt() {
    *this = ::std::move(from);
  }

  inline IntInt& operator=(const IntInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntInt& operator=(IntInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntInt* internal_default_instance() {
    return reinterpret_cast<const IntInt*>(
               &_IntInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IntInt& a, IntInt& b) {
    a.Swap(&b);
  }
  inline void Swap(IntInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntInt& from) {
    IntInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntInt";
  }
  protected:
  explicit IntInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 key = 1;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t key_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class IntFloat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntFloat) */ {
 public:
  inline IntFloat() : IntFloat(nullptr) {}
  ~IntFloat() override;
  explicit PROTOBUF_CONSTEXPR IntFloat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntFloat(const IntFloat& from);
  IntFloat(IntFloat&& from) noexcept
    : IntFloat() {
    *this = ::std::move(from);
  }

  inline IntFloat& operator=(const IntFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntFloat& operator=(IntFloat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntFloat& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntFloat* internal_default_instance() {
    return reinterpret_cast<const IntFloat*>(
               &_IntFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IntFloat& a, IntFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(IntFloat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntFloat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntFloat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntFloat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntFloat& from) {
    IntFloat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntFloat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntFloat";
  }
  protected:
  explicit IntFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 key = 1;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // float value = 2;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:IntFloat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t key_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class LongFloat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LongFloat) */ {
 public:
  inline LongFloat() : LongFloat(nullptr) {}
  ~LongFloat() override;
  explicit PROTOBUF_CONSTEXPR LongFloat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongFloat(const LongFloat& from);
  LongFloat(LongFloat&& from) noexcept
    : LongFloat() {
    *this = ::std::move(from);
  }

  inline LongFloat& operator=(const LongFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongFloat& operator=(LongFloat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongFloat& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongFloat* internal_default_instance() {
    return reinterpret_cast<const LongFloat*>(
               &_LongFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LongFloat& a, LongFloat& b) {
    a.Swap(&b);
  }
  inline void Swap(LongFloat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongFloat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongFloat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongFloat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongFloat& from) {
    LongFloat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongFloat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LongFloat";
  }
  protected:
  explicit LongFloat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int64 key = 1;
  void clear_key();
  int64_t key() const;
  void set_key(int64_t value);
  private:
  int64_t _internal_key() const;
  void _internal_set_key(int64_t value);
  public:

  // float value = 2;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:LongFloat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t key_;
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class LongInt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LongInt) */ {
 public:
  inline LongInt() : LongInt(nullptr) {}
  ~LongInt() override;
  explicit PROTOBUF_CONSTEXPR LongInt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongInt(const LongInt& from);
  LongInt(LongInt&& from) noexcept
    : LongInt() {
    *this = ::std::move(from);
  }

  inline LongInt& operator=(const LongInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongInt& operator=(LongInt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongInt& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongInt* internal_default_instance() {
    return reinterpret_cast<const LongInt*>(
               &_LongInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LongInt& a, LongInt& b) {
    a.Swap(&b);
  }
  inline void Swap(LongInt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongInt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongInt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongInt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongInt& from) {
    LongInt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongInt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LongInt";
  }
  protected:
  explicit LongInt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int64 key = 1;
  void clear_key();
  int64_t key() const;
  void set_key(int64_t value);
  private:
  int64_t _internal_key() const;
  void _internal_set_key(int64_t value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LongInt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t key_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class StrIntList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StrIntList) */ {
 public:
  inline StrIntList() : StrIntList(nullptr) {}
  ~StrIntList() override;
  explicit PROTOBUF_CONSTEXPR StrIntList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrIntList(const StrIntList& from);
  StrIntList(StrIntList&& from) noexcept
    : StrIntList() {
    *this = ::std::move(from);
  }

  inline StrIntList& operator=(const StrIntList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrIntList& operator=(StrIntList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrIntList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrIntList* internal_default_instance() {
    return reinterpret_cast<const StrIntList*>(
               &_StrIntList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StrIntList& a, StrIntList& b) {
    a.Swap(&b);
  }
  inline void Swap(StrIntList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrIntList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrIntList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrIntList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrIntList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrIntList& from) {
    StrIntList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrIntList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StrIntList";
  }
  protected:
  explicit StrIntList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .StrInt value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::StrInt* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrInt >*
      mutable_value();
  private:
  const ::StrInt& _internal_value(int index) const;
  ::StrInt* _internal_add_value();
  public:
  const ::StrInt& value(int index) const;
  ::StrInt* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrInt >&
      value() const;

  // @@protoc_insertion_point(class_scope:StrIntList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrInt > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class StrFloatList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StrFloatList) */ {
 public:
  inline StrFloatList() : StrFloatList(nullptr) {}
  ~StrFloatList() override;
  explicit PROTOBUF_CONSTEXPR StrFloatList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrFloatList(const StrFloatList& from);
  StrFloatList(StrFloatList&& from) noexcept
    : StrFloatList() {
    *this = ::std::move(from);
  }

  inline StrFloatList& operator=(const StrFloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrFloatList& operator=(StrFloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrFloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrFloatList* internal_default_instance() {
    return reinterpret_cast<const StrFloatList*>(
               &_StrFloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StrFloatList& a, StrFloatList& b) {
    a.Swap(&b);
  }
  inline void Swap(StrFloatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrFloatList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrFloatList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrFloatList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrFloatList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrFloatList& from) {
    StrFloatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrFloatList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StrFloatList";
  }
  protected:
  explicit StrFloatList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .StrFloat value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::StrFloat* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrFloat >*
      mutable_value();
  private:
  const ::StrFloat& _internal_value(int index) const;
  ::StrFloat* _internal_add_value();
  public:
  const ::StrFloat& value(int index) const;
  ::StrFloat* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrFloat >&
      value() const;

  // @@protoc_insertion_point(class_scope:StrFloatList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrFloat > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class IntFloatList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntFloatList) */ {
 public:
  inline IntFloatList() : IntFloatList(nullptr) {}
  ~IntFloatList() override;
  explicit PROTOBUF_CONSTEXPR IntFloatList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntFloatList(const IntFloatList& from);
  IntFloatList(IntFloatList&& from) noexcept
    : IntFloatList() {
    *this = ::std::move(from);
  }

  inline IntFloatList& operator=(const IntFloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntFloatList& operator=(IntFloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntFloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntFloatList* internal_default_instance() {
    return reinterpret_cast<const IntFloatList*>(
               &_IntFloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IntFloatList& a, IntFloatList& b) {
    a.Swap(&b);
  }
  inline void Swap(IntFloatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntFloatList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntFloatList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntFloatList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntFloatList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntFloatList& from) {
    IntFloatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntFloatList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntFloatList";
  }
  protected:
  explicit IntFloatList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .IntFloat value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::IntFloat* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntFloat >*
      mutable_value();
  private:
  const ::IntFloat& _internal_value(int index) const;
  ::IntFloat* _internal_add_value();
  public:
  const ::IntFloat& value(int index) const;
  ::IntFloat* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntFloat >&
      value() const;

  // @@protoc_insertion_point(class_scope:IntFloatList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntFloat > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class IntIntList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntIntList) */ {
 public:
  inline IntIntList() : IntIntList(nullptr) {}
  ~IntIntList() override;
  explicit PROTOBUF_CONSTEXPR IntIntList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntIntList(const IntIntList& from);
  IntIntList(IntIntList&& from) noexcept
    : IntIntList() {
    *this = ::std::move(from);
  }

  inline IntIntList& operator=(const IntIntList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntIntList& operator=(IntIntList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntIntList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntIntList* internal_default_instance() {
    return reinterpret_cast<const IntIntList*>(
               &_IntIntList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IntIntList& a, IntIntList& b) {
    a.Swap(&b);
  }
  inline void Swap(IntIntList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntIntList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntIntList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntIntList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntIntList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntIntList& from) {
    IntIntList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntIntList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntIntList";
  }
  protected:
  explicit IntIntList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .IntInt value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::IntInt* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntInt >*
      mutable_value();
  private:
  const ::IntInt& _internal_value(int index) const;
  ::IntInt* _internal_add_value();
  public:
  const ::IntInt& value(int index) const;
  ::IntInt* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntInt >&
      value() const;

  // @@protoc_insertion_point(class_scope:IntIntList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntInt > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class LongIntList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LongIntList) */ {
 public:
  inline LongIntList() : LongIntList(nullptr) {}
  ~LongIntList() override;
  explicit PROTOBUF_CONSTEXPR LongIntList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongIntList(const LongIntList& from);
  LongIntList(LongIntList&& from) noexcept
    : LongIntList() {
    *this = ::std::move(from);
  }

  inline LongIntList& operator=(const LongIntList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongIntList& operator=(LongIntList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongIntList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongIntList* internal_default_instance() {
    return reinterpret_cast<const LongIntList*>(
               &_LongIntList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LongIntList& a, LongIntList& b) {
    a.Swap(&b);
  }
  inline void Swap(LongIntList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongIntList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongIntList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongIntList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongIntList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongIntList& from) {
    LongIntList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongIntList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LongIntList";
  }
  protected:
  explicit LongIntList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .LongInt value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::LongInt* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongInt >*
      mutable_value();
  private:
  const ::LongInt& _internal_value(int index) const;
  ::LongInt* _internal_add_value();
  public:
  const ::LongInt& value(int index) const;
  ::LongInt* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongInt >&
      value() const;

  // @@protoc_insertion_point(class_scope:LongIntList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongInt > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class LongFloatList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LongFloatList) */ {
 public:
  inline LongFloatList() : LongFloatList(nullptr) {}
  ~LongFloatList() override;
  explicit PROTOBUF_CONSTEXPR LongFloatList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongFloatList(const LongFloatList& from);
  LongFloatList(LongFloatList&& from) noexcept
    : LongFloatList() {
    *this = ::std::move(from);
  }

  inline LongFloatList& operator=(const LongFloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongFloatList& operator=(LongFloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongFloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongFloatList* internal_default_instance() {
    return reinterpret_cast<const LongFloatList*>(
               &_LongFloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LongFloatList& a, LongFloatList& b) {
    a.Swap(&b);
  }
  inline void Swap(LongFloatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongFloatList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongFloatList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongFloatList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongFloatList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongFloatList& from) {
    LongFloatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongFloatList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LongFloatList";
  }
  protected:
  explicit LongFloatList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .LongFloat value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::LongFloat* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongFloat >*
      mutable_value();
  private:
  const ::LongFloat& _internal_value(int index) const;
  ::LongFloat* _internal_add_value();
  public:
  const ::LongFloat& value(int index) const;
  ::LongFloat* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongFloat >&
      value() const;

  // @@protoc_insertion_point(class_scope:LongFloatList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongFloat > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class FloatList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FloatList) */ {
 public:
  inline FloatList() : FloatList(nullptr) {}
  ~FloatList() override;
  explicit PROTOBUF_CONSTEXPR FloatList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatList(const FloatList& from);
  FloatList(FloatList&& from) noexcept
    : FloatList() {
    *this = ::std::move(from);
  }

  inline FloatList& operator=(const FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatList& operator=(FloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatList* internal_default_instance() {
    return reinterpret_cast<const FloatList*>(
               &_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FloatList& a, FloatList& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FloatList& from) {
    FloatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FloatList";
  }
  protected:
  explicit FloatList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated float value = 1 [packed = true];
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  float _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_value() const;
  void _internal_add_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_value();
  public:
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:FloatList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class LongList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LongList) */ {
 public:
  inline LongList() : LongList(nullptr) {}
  ~LongList() override;
  explicit PROTOBUF_CONSTEXPR LongList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongList(const LongList& from);
  LongList(LongList&& from) noexcept
    : LongList() {
    *this = ::std::move(from);
  }

  inline LongList& operator=(const LongList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongList& operator=(LongList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongList* internal_default_instance() {
    return reinterpret_cast<const LongList*>(
               &_LongList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LongList& a, LongList& b) {
    a.Swap(&b);
  }
  inline void Swap(LongList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongList& from) {
    LongList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LongList";
  }
  protected:
  explicit LongList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated int64 value = 1 [packed = true];
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  int64_t _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_value() const;
  void _internal_add_value(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_value();
  public:
  int64_t value(int index) const;
  void set_value(int index, int64_t value);
  void add_value(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:LongList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > value_;
    mutable std::atomic<int> _value_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class IntList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntList) */ {
 public:
  inline IntList() : IntList(nullptr) {}
  ~IntList() override;
  explicit PROTOBUF_CONSTEXPR IntList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntList(const IntList& from);
  IntList(IntList&& from) noexcept
    : IntList() {
    *this = ::std::move(from);
  }

  inline IntList& operator=(const IntList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntList& operator=(IntList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntList* internal_default_instance() {
    return reinterpret_cast<const IntList*>(
               &_IntList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IntList& a, IntList& b) {
    a.Swap(&b);
  }
  inline void Swap(IntList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntList& from) {
    IntList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntList";
  }
  protected:
  explicit IntList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated int32 value = 1 [packed = true];
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  private:
  int32_t _internal_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_value() const;
  void _internal_add_value(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_value();
  public:
  int32_t value(int index) const;
  void set_value(int index, int32_t value);
  void add_value(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:IntList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > value_;
    mutable std::atomic<int> _value_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class StrList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StrList) */ {
 public:
  inline StrList() : StrList(nullptr) {}
  ~StrList() override;
  explicit PROTOBUF_CONSTEXPR StrList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrList(const StrList& from);
  StrList(StrList&& from) noexcept
    : StrList() {
    *this = ::std::move(from);
  }

  inline StrList& operator=(const StrList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrList& operator=(StrList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrList* internal_default_instance() {
    return reinterpret_cast<const StrList*>(
               &_StrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StrList& a, StrList& b) {
    a.Swap(&b);
  }
  inline void Swap(StrList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrList& from) {
    StrList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StrList";
  }
  protected:
  explicit StrList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // @@protoc_insertion_point(class_scope:StrList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class UserActionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserActionList) */ {
 public:
  inline UserActionList() : UserActionList(nullptr) {}
  ~UserActionList() override;
  explicit PROTOBUF_CONSTEXPR UserActionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserActionList(const UserActionList& from);
  UserActionList(UserActionList&& from) noexcept
    : UserActionList() {
    *this = ::std::move(from);
  }

  inline UserActionList& operator=(const UserActionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserActionList& operator=(UserActionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserActionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserActionList* internal_default_instance() {
    return reinterpret_cast<const UserActionList*>(
               &_UserActionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UserActionList& a, UserActionList& b) {
    a.Swap(&b);
  }
  inline void Swap(UserActionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserActionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserActionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserActionList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserActionList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserActionList& from) {
    UserActionList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserActionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserActionList";
  }
  protected:
  explicit UserActionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .UserAction value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::UserAction* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserAction >*
      mutable_value();
  private:
  const ::UserAction& _internal_value(int index) const;
  ::UserAction* _internal_add_value();
  public:
  const ::UserAction& value(int index) const;
  ::UserAction* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserAction >&
      value() const;

  // @@protoc_insertion_point(class_scope:UserActionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserAction > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  explicit PROTOBUF_CONSTEXPR Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Item";
  }
  protected:
  explicit Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kCollectionIdFieldNumber = 2,
    kStoreIdFieldNumber = 3,
    kFirstTimeFieldNumber = 4,
    kLastSecondTimeFieldNumber = 5,
    kLastTimeFieldNumber = 6,
    kCntFieldNumber = 7,
  };
  // string item_id = 1;
  void clear_item_id();
  const std::string item_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_item_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* item_id);
  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(const std::string& value);
  std::string* _internal_mutable_item_id();
  public:

  // string collection_id = 2;
  void clear_collection_id();
  const std::string& collection_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collection_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collection_id();
  PROTOBUF_NODISCARD std::string* release_collection_id();
  void set_allocated_collection_id(std::string* collection_id);
  private:
  const std::string& _internal_collection_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collection_id(const std::string& value);
  std::string* _internal_mutable_collection_id();
  public:

  // int64 store_id = 3;
  void clear_store_id();
  int64_t store_id() const;
  void set_store_id(int64_t value);
  private:
  int64_t _internal_store_id() const;
  void _internal_set_store_id(int64_t value);
  public:

  // int64 first_time = 4;
  void clear_first_time();
  int64_t first_time() const;
  void set_first_time(int64_t value);
  private:
  int64_t _internal_first_time() const;
  void _internal_set_first_time(int64_t value);
  public:

  // int64 last_second_time = 5;
  void clear_last_second_time();
  int64_t last_second_time() const;
  void set_last_second_time(int64_t value);
  private:
  int64_t _internal_last_second_time() const;
  void _internal_set_last_second_time(int64_t value);
  public:

  // int64 last_time = 6;
  void clear_last_time();
  int64_t last_time() const;
  void set_last_time(int64_t value);
  private:
  int64_t _internal_last_time() const;
  void _internal_set_last_time(int64_t value);
  public:

  // int64 cnt = 7;
  void clear_cnt();
  int64_t cnt() const;
  void set_cnt(int64_t value);
  private:
  int64_t _internal_cnt() const;
  void _internal_set_cnt(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr item_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_id_;
    int64_t store_id_;
    int64_t first_time_;
    int64_t last_second_time_;
    int64_t last_time_;
    int64_t cnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class RTUserActionList_ItemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RTUserActionList_ItemsEntry_DoNotUse, 
    std::string, ::Item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RTUserActionList_ItemsEntry_DoNotUse, 
    std::string, ::Item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  RTUserActionList_ItemsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RTUserActionList_ItemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RTUserActionList_ItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RTUserActionList_ItemsEntry_DoNotUse& other);
  static const RTUserActionList_ItemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RTUserActionList_ItemsEntry_DoNotUse*>(&_RTUserActionList_ItemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "RTUserActionList.ItemsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_features_2eproto;
};

// -------------------------------------------------------------------

class RTUserActionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RTUserActionList) */ {
 public:
  inline RTUserActionList() : RTUserActionList(nullptr) {}
  ~RTUserActionList() override;
  explicit PROTOBUF_CONSTEXPR RTUserActionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTUserActionList(const RTUserActionList& from);
  RTUserActionList(RTUserActionList&& from) noexcept
    : RTUserActionList() {
    *this = ::std::move(from);
  }

  inline RTUserActionList& operator=(const RTUserActionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTUserActionList& operator=(RTUserActionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTUserActionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTUserActionList* internal_default_instance() {
    return reinterpret_cast<const RTUserActionList*>(
               &_RTUserActionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RTUserActionList& a, RTUserActionList& b) {
    a.Swap(&b);
  }
  inline void Swap(RTUserActionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTUserActionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTUserActionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTUserActionList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTUserActionList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RTUserActionList& from) {
    RTUserActionList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTUserActionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RTUserActionList";
  }
  protected:
  explicit RTUserActionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // map<string, .Item> items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >&
      _internal_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >*
      _internal_mutable_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >&
      items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:RTUserActionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RTUserActionList_ItemsEntry_DoNotUse,
        std::string, ::Item,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class ItemAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ItemAction) */ {
 public:
  inline ItemAction() : ItemAction(nullptr) {}
  ~ItemAction() override;
  explicit PROTOBUF_CONSTEXPR ItemAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemAction(const ItemAction& from);
  ItemAction(ItemAction&& from) noexcept
    : ItemAction() {
    *this = ::std::move(from);
  }

  inline ItemAction& operator=(const ItemAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemAction& operator=(ItemAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemAction* internal_default_instance() {
    return reinterpret_cast<const ItemAction*>(
               &_ItemAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ItemAction& a, ItemAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemAction& from) {
    ItemAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ItemAction";
  }
  protected:
  explicit ItemAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
    kContextFieldNumber = 2,
    kDateFieldNumber = 7,
    kCntFieldNumber = 3,
    kDistCntFieldNumber = 4,
    kClickCntFieldNumber = 5,
    kBuyCntFieldNumber = 6,
  };
  // string event = 1;
  void clear_event();
  const std::string& event() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event();
  PROTOBUF_NODISCARD std::string* release_event();
  void set_allocated_event(std::string* event);
  private:
  const std::string& _internal_event() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event(const std::string& value);
  std::string* _internal_mutable_event();
  public:

  // string context = 2;
  void clear_context();
  const std::string& context() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context();
  PROTOBUF_NODISCARD std::string* release_context();
  void set_allocated_context(std::string* context);
  private:
  const std::string& _internal_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context(const std::string& value);
  std::string* _internal_mutable_context();
  public:

  // string date = 7;
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // int32 cnt = 3;
  void clear_cnt();
  int32_t cnt() const;
  void set_cnt(int32_t value);
  private:
  int32_t _internal_cnt() const;
  void _internal_set_cnt(int32_t value);
  public:

  // int32 dist_cnt = 4;
  void clear_dist_cnt();
  int32_t dist_cnt() const;
  void set_dist_cnt(int32_t value);
  private:
  int32_t _internal_dist_cnt() const;
  void _internal_set_dist_cnt(int32_t value);
  public:

  // int32 click_cnt = 5;
  void clear_click_cnt();
  int32_t click_cnt() const;
  void set_click_cnt(int32_t value);
  private:
  int32_t _internal_click_cnt() const;
  void _internal_set_click_cnt(int32_t value);
  public:

  // int32 buy_cnt = 6;
  void clear_buy_cnt();
  int32_t buy_cnt() const;
  void set_buy_cnt(int32_t value);
  private:
  int32_t _internal_buy_cnt() const;
  void _internal_set_buy_cnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ItemAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
    int32_t cnt_;
    int32_t dist_cnt_;
    int32_t click_cnt_;
    int32_t buy_cnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// -------------------------------------------------------------------

class ItemActionList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ItemActionList) */ {
 public:
  inline ItemActionList() : ItemActionList(nullptr) {}
  ~ItemActionList() override;
  explicit PROTOBUF_CONSTEXPR ItemActionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemActionList(const ItemActionList& from);
  ItemActionList(ItemActionList&& from) noexcept
    : ItemActionList() {
    *this = ::std::move(from);
  }

  inline ItemActionList& operator=(const ItemActionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemActionList& operator=(ItemActionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemActionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemActionList* internal_default_instance() {
    return reinterpret_cast<const ItemActionList*>(
               &_ItemActionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ItemActionList& a, ItemActionList& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemActionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemActionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemActionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemActionList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemActionList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItemActionList& from) {
    ItemActionList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemActionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ItemActionList";
  }
  protected:
  explicit ItemActionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .ItemAction value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::ItemAction* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemAction >*
      mutable_value();
  private:
  const ::ItemAction& _internal_value(int index) const;
  ::ItemAction* _internal_add_value();
  public:
  const ::ItemAction& value(int index) const;
  ::ItemAction* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemAction >&
      value() const;

  // @@protoc_insertion_point(class_scope:ItemActionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemAction > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_features_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BatchFeatures

// repeated .Features value = 1;
inline int BatchFeatures::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int BatchFeatures::value_size() const {
  return _internal_value_size();
}
inline void BatchFeatures::clear_value() {
  _impl_.value_.Clear();
}
inline ::Features* BatchFeatures::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:BatchFeatures.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Features >*
BatchFeatures::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:BatchFeatures.value)
  return &_impl_.value_;
}
inline const ::Features& BatchFeatures::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::Features& BatchFeatures::value(int index) const {
  // @@protoc_insertion_point(field_get:BatchFeatures.value)
  return _internal_value(index);
}
inline ::Features* BatchFeatures::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::Features* BatchFeatures::add_value() {
  ::Features* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:BatchFeatures.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Features >&
BatchFeatures::value() const {
  // @@protoc_insertion_point(field_list:BatchFeatures.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Features

// string key = 1;
inline void Features::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Features::key() const {
  // @@protoc_insertion_point(field_get:Features.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Features::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Features.key)
}
inline std::string* Features::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:Features.key)
  return _s;
}
inline const std::string& Features::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Features::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Features::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Features::release_key() {
  // @@protoc_insertion_point(field_release:Features.key)
  return _impl_.key_.Release();
}
inline void Features::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Features.key)
}

// map<string, .Feature> value = 2;
inline int Features::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int Features::value_size() const {
  return _internal_value_size();
}
inline void Features::clear_value() {
  _impl_.value_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >&
Features::_internal_value() const {
  return _impl_.value_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >&
Features::value() const {
  // @@protoc_insertion_point(field_map:Features.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >*
Features::_internal_mutable_value() {
  return _impl_.value_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Feature >*
Features::mutable_value() {
  // @@protoc_insertion_point(field_mutable_map:Features.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// Feature

// .StrIntList str_int_list = 1;
inline bool Feature::_internal_has_str_int_list() const {
  return kind_case() == kStrIntList;
}
inline bool Feature::has_str_int_list() const {
  return _internal_has_str_int_list();
}
inline void Feature::set_has_str_int_list() {
  _impl_._oneof_case_[0] = kStrIntList;
}
inline void Feature::clear_str_int_list() {
  if (_internal_has_str_int_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.str_int_list_;
    }
    clear_has_kind();
  }
}
inline ::StrIntList* Feature::release_str_int_list() {
  // @@protoc_insertion_point(field_release:Feature.str_int_list)
  if (_internal_has_str_int_list()) {
    clear_has_kind();
    ::StrIntList* temp = _impl_.kind_.str_int_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.str_int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StrIntList& Feature::_internal_str_int_list() const {
  return _internal_has_str_int_list()
      ? *_impl_.kind_.str_int_list_
      : reinterpret_cast< ::StrIntList&>(::_StrIntList_default_instance_);
}
inline const ::StrIntList& Feature::str_int_list() const {
  // @@protoc_insertion_point(field_get:Feature.str_int_list)
  return _internal_str_int_list();
}
inline ::StrIntList* Feature::unsafe_arena_release_str_int_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.str_int_list)
  if (_internal_has_str_int_list()) {
    clear_has_kind();
    ::StrIntList* temp = _impl_.kind_.str_int_list_;
    _impl_.kind_.str_int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_str_int_list(::StrIntList* str_int_list) {
  clear_kind();
  if (str_int_list) {
    set_has_str_int_list();
    _impl_.kind_.str_int_list_ = str_int_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.str_int_list)
}
inline ::StrIntList* Feature::_internal_mutable_str_int_list() {
  if (!_internal_has_str_int_list()) {
    clear_kind();
    set_has_str_int_list();
    _impl_.kind_.str_int_list_ = CreateMaybeMessage< ::StrIntList >(GetArenaForAllocation());
  }
  return _impl_.kind_.str_int_list_;
}
inline ::StrIntList* Feature::mutable_str_int_list() {
  ::StrIntList* _msg = _internal_mutable_str_int_list();
  // @@protoc_insertion_point(field_mutable:Feature.str_int_list)
  return _msg;
}

// .StrFloatList str_float_list = 2;
inline bool Feature::_internal_has_str_float_list() const {
  return kind_case() == kStrFloatList;
}
inline bool Feature::has_str_float_list() const {
  return _internal_has_str_float_list();
}
inline void Feature::set_has_str_float_list() {
  _impl_._oneof_case_[0] = kStrFloatList;
}
inline void Feature::clear_str_float_list() {
  if (_internal_has_str_float_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.str_float_list_;
    }
    clear_has_kind();
  }
}
inline ::StrFloatList* Feature::release_str_float_list() {
  // @@protoc_insertion_point(field_release:Feature.str_float_list)
  if (_internal_has_str_float_list()) {
    clear_has_kind();
    ::StrFloatList* temp = _impl_.kind_.str_float_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.str_float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StrFloatList& Feature::_internal_str_float_list() const {
  return _internal_has_str_float_list()
      ? *_impl_.kind_.str_float_list_
      : reinterpret_cast< ::StrFloatList&>(::_StrFloatList_default_instance_);
}
inline const ::StrFloatList& Feature::str_float_list() const {
  // @@protoc_insertion_point(field_get:Feature.str_float_list)
  return _internal_str_float_list();
}
inline ::StrFloatList* Feature::unsafe_arena_release_str_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.str_float_list)
  if (_internal_has_str_float_list()) {
    clear_has_kind();
    ::StrFloatList* temp = _impl_.kind_.str_float_list_;
    _impl_.kind_.str_float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_str_float_list(::StrFloatList* str_float_list) {
  clear_kind();
  if (str_float_list) {
    set_has_str_float_list();
    _impl_.kind_.str_float_list_ = str_float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.str_float_list)
}
inline ::StrFloatList* Feature::_internal_mutable_str_float_list() {
  if (!_internal_has_str_float_list()) {
    clear_kind();
    set_has_str_float_list();
    _impl_.kind_.str_float_list_ = CreateMaybeMessage< ::StrFloatList >(GetArenaForAllocation());
  }
  return _impl_.kind_.str_float_list_;
}
inline ::StrFloatList* Feature::mutable_str_float_list() {
  ::StrFloatList* _msg = _internal_mutable_str_float_list();
  // @@protoc_insertion_point(field_mutable:Feature.str_float_list)
  return _msg;
}

// .IntIntList int_int_list = 3;
inline bool Feature::_internal_has_int_int_list() const {
  return kind_case() == kIntIntList;
}
inline bool Feature::has_int_int_list() const {
  return _internal_has_int_int_list();
}
inline void Feature::set_has_int_int_list() {
  _impl_._oneof_case_[0] = kIntIntList;
}
inline void Feature::clear_int_int_list() {
  if (_internal_has_int_int_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.int_int_list_;
    }
    clear_has_kind();
  }
}
inline ::IntIntList* Feature::release_int_int_list() {
  // @@protoc_insertion_point(field_release:Feature.int_int_list)
  if (_internal_has_int_int_list()) {
    clear_has_kind();
    ::IntIntList* temp = _impl_.kind_.int_int_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.int_int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntIntList& Feature::_internal_int_int_list() const {
  return _internal_has_int_int_list()
      ? *_impl_.kind_.int_int_list_
      : reinterpret_cast< ::IntIntList&>(::_IntIntList_default_instance_);
}
inline const ::IntIntList& Feature::int_int_list() const {
  // @@protoc_insertion_point(field_get:Feature.int_int_list)
  return _internal_int_int_list();
}
inline ::IntIntList* Feature::unsafe_arena_release_int_int_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.int_int_list)
  if (_internal_has_int_int_list()) {
    clear_has_kind();
    ::IntIntList* temp = _impl_.kind_.int_int_list_;
    _impl_.kind_.int_int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_int_int_list(::IntIntList* int_int_list) {
  clear_kind();
  if (int_int_list) {
    set_has_int_int_list();
    _impl_.kind_.int_int_list_ = int_int_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.int_int_list)
}
inline ::IntIntList* Feature::_internal_mutable_int_int_list() {
  if (!_internal_has_int_int_list()) {
    clear_kind();
    set_has_int_int_list();
    _impl_.kind_.int_int_list_ = CreateMaybeMessage< ::IntIntList >(GetArenaForAllocation());
  }
  return _impl_.kind_.int_int_list_;
}
inline ::IntIntList* Feature::mutable_int_int_list() {
  ::IntIntList* _msg = _internal_mutable_int_int_list();
  // @@protoc_insertion_point(field_mutable:Feature.int_int_list)
  return _msg;
}

// .IntFloatList int_float_list = 4;
inline bool Feature::_internal_has_int_float_list() const {
  return kind_case() == kIntFloatList;
}
inline bool Feature::has_int_float_list() const {
  return _internal_has_int_float_list();
}
inline void Feature::set_has_int_float_list() {
  _impl_._oneof_case_[0] = kIntFloatList;
}
inline void Feature::clear_int_float_list() {
  if (_internal_has_int_float_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.int_float_list_;
    }
    clear_has_kind();
  }
}
inline ::IntFloatList* Feature::release_int_float_list() {
  // @@protoc_insertion_point(field_release:Feature.int_float_list)
  if (_internal_has_int_float_list()) {
    clear_has_kind();
    ::IntFloatList* temp = _impl_.kind_.int_float_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.int_float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntFloatList& Feature::_internal_int_float_list() const {
  return _internal_has_int_float_list()
      ? *_impl_.kind_.int_float_list_
      : reinterpret_cast< ::IntFloatList&>(::_IntFloatList_default_instance_);
}
inline const ::IntFloatList& Feature::int_float_list() const {
  // @@protoc_insertion_point(field_get:Feature.int_float_list)
  return _internal_int_float_list();
}
inline ::IntFloatList* Feature::unsafe_arena_release_int_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.int_float_list)
  if (_internal_has_int_float_list()) {
    clear_has_kind();
    ::IntFloatList* temp = _impl_.kind_.int_float_list_;
    _impl_.kind_.int_float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_int_float_list(::IntFloatList* int_float_list) {
  clear_kind();
  if (int_float_list) {
    set_has_int_float_list();
    _impl_.kind_.int_float_list_ = int_float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.int_float_list)
}
inline ::IntFloatList* Feature::_internal_mutable_int_float_list() {
  if (!_internal_has_int_float_list()) {
    clear_kind();
    set_has_int_float_list();
    _impl_.kind_.int_float_list_ = CreateMaybeMessage< ::IntFloatList >(GetArenaForAllocation());
  }
  return _impl_.kind_.int_float_list_;
}
inline ::IntFloatList* Feature::mutable_int_float_list() {
  ::IntFloatList* _msg = _internal_mutable_int_float_list();
  // @@protoc_insertion_point(field_mutable:Feature.int_float_list)
  return _msg;
}

// .LongIntList long_int_list = 5;
inline bool Feature::_internal_has_long_int_list() const {
  return kind_case() == kLongIntList;
}
inline bool Feature::has_long_int_list() const {
  return _internal_has_long_int_list();
}
inline void Feature::set_has_long_int_list() {
  _impl_._oneof_case_[0] = kLongIntList;
}
inline void Feature::clear_long_int_list() {
  if (_internal_has_long_int_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.long_int_list_;
    }
    clear_has_kind();
  }
}
inline ::LongIntList* Feature::release_long_int_list() {
  // @@protoc_insertion_point(field_release:Feature.long_int_list)
  if (_internal_has_long_int_list()) {
    clear_has_kind();
    ::LongIntList* temp = _impl_.kind_.long_int_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.long_int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LongIntList& Feature::_internal_long_int_list() const {
  return _internal_has_long_int_list()
      ? *_impl_.kind_.long_int_list_
      : reinterpret_cast< ::LongIntList&>(::_LongIntList_default_instance_);
}
inline const ::LongIntList& Feature::long_int_list() const {
  // @@protoc_insertion_point(field_get:Feature.long_int_list)
  return _internal_long_int_list();
}
inline ::LongIntList* Feature::unsafe_arena_release_long_int_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.long_int_list)
  if (_internal_has_long_int_list()) {
    clear_has_kind();
    ::LongIntList* temp = _impl_.kind_.long_int_list_;
    _impl_.kind_.long_int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_long_int_list(::LongIntList* long_int_list) {
  clear_kind();
  if (long_int_list) {
    set_has_long_int_list();
    _impl_.kind_.long_int_list_ = long_int_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.long_int_list)
}
inline ::LongIntList* Feature::_internal_mutable_long_int_list() {
  if (!_internal_has_long_int_list()) {
    clear_kind();
    set_has_long_int_list();
    _impl_.kind_.long_int_list_ = CreateMaybeMessage< ::LongIntList >(GetArenaForAllocation());
  }
  return _impl_.kind_.long_int_list_;
}
inline ::LongIntList* Feature::mutable_long_int_list() {
  ::LongIntList* _msg = _internal_mutable_long_int_list();
  // @@protoc_insertion_point(field_mutable:Feature.long_int_list)
  return _msg;
}

// .LongFloatList long_float_list = 6;
inline bool Feature::_internal_has_long_float_list() const {
  return kind_case() == kLongFloatList;
}
inline bool Feature::has_long_float_list() const {
  return _internal_has_long_float_list();
}
inline void Feature::set_has_long_float_list() {
  _impl_._oneof_case_[0] = kLongFloatList;
}
inline void Feature::clear_long_float_list() {
  if (_internal_has_long_float_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.long_float_list_;
    }
    clear_has_kind();
  }
}
inline ::LongFloatList* Feature::release_long_float_list() {
  // @@protoc_insertion_point(field_release:Feature.long_float_list)
  if (_internal_has_long_float_list()) {
    clear_has_kind();
    ::LongFloatList* temp = _impl_.kind_.long_float_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.long_float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LongFloatList& Feature::_internal_long_float_list() const {
  return _internal_has_long_float_list()
      ? *_impl_.kind_.long_float_list_
      : reinterpret_cast< ::LongFloatList&>(::_LongFloatList_default_instance_);
}
inline const ::LongFloatList& Feature::long_float_list() const {
  // @@protoc_insertion_point(field_get:Feature.long_float_list)
  return _internal_long_float_list();
}
inline ::LongFloatList* Feature::unsafe_arena_release_long_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.long_float_list)
  if (_internal_has_long_float_list()) {
    clear_has_kind();
    ::LongFloatList* temp = _impl_.kind_.long_float_list_;
    _impl_.kind_.long_float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_long_float_list(::LongFloatList* long_float_list) {
  clear_kind();
  if (long_float_list) {
    set_has_long_float_list();
    _impl_.kind_.long_float_list_ = long_float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.long_float_list)
}
inline ::LongFloatList* Feature::_internal_mutable_long_float_list() {
  if (!_internal_has_long_float_list()) {
    clear_kind();
    set_has_long_float_list();
    _impl_.kind_.long_float_list_ = CreateMaybeMessage< ::LongFloatList >(GetArenaForAllocation());
  }
  return _impl_.kind_.long_float_list_;
}
inline ::LongFloatList* Feature::mutable_long_float_list() {
  ::LongFloatList* _msg = _internal_mutable_long_float_list();
  // @@protoc_insertion_point(field_mutable:Feature.long_float_list)
  return _msg;
}

// .StrList str_list = 7;
inline bool Feature::_internal_has_str_list() const {
  return kind_case() == kStrList;
}
inline bool Feature::has_str_list() const {
  return _internal_has_str_list();
}
inline void Feature::set_has_str_list() {
  _impl_._oneof_case_[0] = kStrList;
}
inline void Feature::clear_str_list() {
  if (_internal_has_str_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.str_list_;
    }
    clear_has_kind();
  }
}
inline ::StrList* Feature::release_str_list() {
  // @@protoc_insertion_point(field_release:Feature.str_list)
  if (_internal_has_str_list()) {
    clear_has_kind();
    ::StrList* temp = _impl_.kind_.str_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.str_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StrList& Feature::_internal_str_list() const {
  return _internal_has_str_list()
      ? *_impl_.kind_.str_list_
      : reinterpret_cast< ::StrList&>(::_StrList_default_instance_);
}
inline const ::StrList& Feature::str_list() const {
  // @@protoc_insertion_point(field_get:Feature.str_list)
  return _internal_str_list();
}
inline ::StrList* Feature::unsafe_arena_release_str_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.str_list)
  if (_internal_has_str_list()) {
    clear_has_kind();
    ::StrList* temp = _impl_.kind_.str_list_;
    _impl_.kind_.str_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_str_list(::StrList* str_list) {
  clear_kind();
  if (str_list) {
    set_has_str_list();
    _impl_.kind_.str_list_ = str_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.str_list)
}
inline ::StrList* Feature::_internal_mutable_str_list() {
  if (!_internal_has_str_list()) {
    clear_kind();
    set_has_str_list();
    _impl_.kind_.str_list_ = CreateMaybeMessage< ::StrList >(GetArenaForAllocation());
  }
  return _impl_.kind_.str_list_;
}
inline ::StrList* Feature::mutable_str_list() {
  ::StrList* _msg = _internal_mutable_str_list();
  // @@protoc_insertion_point(field_mutable:Feature.str_list)
  return _msg;
}

// .IntList int_list = 8;
inline bool Feature::_internal_has_int_list() const {
  return kind_case() == kIntList;
}
inline bool Feature::has_int_list() const {
  return _internal_has_int_list();
}
inline void Feature::set_has_int_list() {
  _impl_._oneof_case_[0] = kIntList;
}
inline void Feature::clear_int_list() {
  if (_internal_has_int_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.int_list_;
    }
    clear_has_kind();
  }
}
inline ::IntList* Feature::release_int_list() {
  // @@protoc_insertion_point(field_release:Feature.int_list)
  if (_internal_has_int_list()) {
    clear_has_kind();
    ::IntList* temp = _impl_.kind_.int_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntList& Feature::_internal_int_list() const {
  return _internal_has_int_list()
      ? *_impl_.kind_.int_list_
      : reinterpret_cast< ::IntList&>(::_IntList_default_instance_);
}
inline const ::IntList& Feature::int_list() const {
  // @@protoc_insertion_point(field_get:Feature.int_list)
  return _internal_int_list();
}
inline ::IntList* Feature::unsafe_arena_release_int_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.int_list)
  if (_internal_has_int_list()) {
    clear_has_kind();
    ::IntList* temp = _impl_.kind_.int_list_;
    _impl_.kind_.int_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_int_list(::IntList* int_list) {
  clear_kind();
  if (int_list) {
    set_has_int_list();
    _impl_.kind_.int_list_ = int_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.int_list)
}
inline ::IntList* Feature::_internal_mutable_int_list() {
  if (!_internal_has_int_list()) {
    clear_kind();
    set_has_int_list();
    _impl_.kind_.int_list_ = CreateMaybeMessage< ::IntList >(GetArenaForAllocation());
  }
  return _impl_.kind_.int_list_;
}
inline ::IntList* Feature::mutable_int_list() {
  ::IntList* _msg = _internal_mutable_int_list();
  // @@protoc_insertion_point(field_mutable:Feature.int_list)
  return _msg;
}

// .LongList long_list = 9;
inline bool Feature::_internal_has_long_list() const {
  return kind_case() == kLongList;
}
inline bool Feature::has_long_list() const {
  return _internal_has_long_list();
}
inline void Feature::set_has_long_list() {
  _impl_._oneof_case_[0] = kLongList;
}
inline void Feature::clear_long_list() {
  if (_internal_has_long_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.long_list_;
    }
    clear_has_kind();
  }
}
inline ::LongList* Feature::release_long_list() {
  // @@protoc_insertion_point(field_release:Feature.long_list)
  if (_internal_has_long_list()) {
    clear_has_kind();
    ::LongList* temp = _impl_.kind_.long_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.long_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LongList& Feature::_internal_long_list() const {
  return _internal_has_long_list()
      ? *_impl_.kind_.long_list_
      : reinterpret_cast< ::LongList&>(::_LongList_default_instance_);
}
inline const ::LongList& Feature::long_list() const {
  // @@protoc_insertion_point(field_get:Feature.long_list)
  return _internal_long_list();
}
inline ::LongList* Feature::unsafe_arena_release_long_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.long_list)
  if (_internal_has_long_list()) {
    clear_has_kind();
    ::LongList* temp = _impl_.kind_.long_list_;
    _impl_.kind_.long_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_long_list(::LongList* long_list) {
  clear_kind();
  if (long_list) {
    set_has_long_list();
    _impl_.kind_.long_list_ = long_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.long_list)
}
inline ::LongList* Feature::_internal_mutable_long_list() {
  if (!_internal_has_long_list()) {
    clear_kind();
    set_has_long_list();
    _impl_.kind_.long_list_ = CreateMaybeMessage< ::LongList >(GetArenaForAllocation());
  }
  return _impl_.kind_.long_list_;
}
inline ::LongList* Feature::mutable_long_list() {
  ::LongList* _msg = _internal_mutable_long_list();
  // @@protoc_insertion_point(field_mutable:Feature.long_list)
  return _msg;
}

// .FloatList float_list = 10;
inline bool Feature::_internal_has_float_list() const {
  return kind_case() == kFloatList;
}
inline bool Feature::has_float_list() const {
  return _internal_has_float_list();
}
inline void Feature::set_has_float_list() {
  _impl_._oneof_case_[0] = kFloatList;
}
inline void Feature::clear_float_list() {
  if (_internal_has_float_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.float_list_;
    }
    clear_has_kind();
  }
}
inline ::FloatList* Feature::release_float_list() {
  // @@protoc_insertion_point(field_release:Feature.float_list)
  if (_internal_has_float_list()) {
    clear_has_kind();
    ::FloatList* temp = _impl_.kind_.float_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FloatList& Feature::_internal_float_list() const {
  return _internal_has_float_list()
      ? *_impl_.kind_.float_list_
      : reinterpret_cast< ::FloatList&>(::_FloatList_default_instance_);
}
inline const ::FloatList& Feature::float_list() const {
  // @@protoc_insertion_point(field_get:Feature.float_list)
  return _internal_float_list();
}
inline ::FloatList* Feature::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.float_list)
  if (_internal_has_float_list()) {
    clear_has_kind();
    ::FloatList* temp = _impl_.kind_.float_list_;
    _impl_.kind_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_float_list(::FloatList* float_list) {
  clear_kind();
  if (float_list) {
    set_has_float_list();
    _impl_.kind_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.float_list)
}
inline ::FloatList* Feature::_internal_mutable_float_list() {
  if (!_internal_has_float_list()) {
    clear_kind();
    set_has_float_list();
    _impl_.kind_.float_list_ = CreateMaybeMessage< ::FloatList >(GetArenaForAllocation());
  }
  return _impl_.kind_.float_list_;
}
inline ::FloatList* Feature::mutable_float_list() {
  ::FloatList* _msg = _internal_mutable_float_list();
  // @@protoc_insertion_point(field_mutable:Feature.float_list)
  return _msg;
}

// .UserActionList user_action_list = 11;
inline bool Feature::_internal_has_user_action_list() const {
  return kind_case() == kUserActionList;
}
inline bool Feature::has_user_action_list() const {
  return _internal_has_user_action_list();
}
inline void Feature::set_has_user_action_list() {
  _impl_._oneof_case_[0] = kUserActionList;
}
inline void Feature::clear_user_action_list() {
  if (_internal_has_user_action_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.user_action_list_;
    }
    clear_has_kind();
  }
}
inline ::UserActionList* Feature::release_user_action_list() {
  // @@protoc_insertion_point(field_release:Feature.user_action_list)
  if (_internal_has_user_action_list()) {
    clear_has_kind();
    ::UserActionList* temp = _impl_.kind_.user_action_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.user_action_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UserActionList& Feature::_internal_user_action_list() const {
  return _internal_has_user_action_list()
      ? *_impl_.kind_.user_action_list_
      : reinterpret_cast< ::UserActionList&>(::_UserActionList_default_instance_);
}
inline const ::UserActionList& Feature::user_action_list() const {
  // @@protoc_insertion_point(field_get:Feature.user_action_list)
  return _internal_user_action_list();
}
inline ::UserActionList* Feature::unsafe_arena_release_user_action_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.user_action_list)
  if (_internal_has_user_action_list()) {
    clear_has_kind();
    ::UserActionList* temp = _impl_.kind_.user_action_list_;
    _impl_.kind_.user_action_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_user_action_list(::UserActionList* user_action_list) {
  clear_kind();
  if (user_action_list) {
    set_has_user_action_list();
    _impl_.kind_.user_action_list_ = user_action_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.user_action_list)
}
inline ::UserActionList* Feature::_internal_mutable_user_action_list() {
  if (!_internal_has_user_action_list()) {
    clear_kind();
    set_has_user_action_list();
    _impl_.kind_.user_action_list_ = CreateMaybeMessage< ::UserActionList >(GetArenaForAllocation());
  }
  return _impl_.kind_.user_action_list_;
}
inline ::UserActionList* Feature::mutable_user_action_list() {
  ::UserActionList* _msg = _internal_mutable_user_action_list();
  // @@protoc_insertion_point(field_mutable:Feature.user_action_list)
  return _msg;
}

// .RTUserActionList rt_user_action_list = 12;
inline bool Feature::_internal_has_rt_user_action_list() const {
  return kind_case() == kRtUserActionList;
}
inline bool Feature::has_rt_user_action_list() const {
  return _internal_has_rt_user_action_list();
}
inline void Feature::set_has_rt_user_action_list() {
  _impl_._oneof_case_[0] = kRtUserActionList;
}
inline void Feature::clear_rt_user_action_list() {
  if (_internal_has_rt_user_action_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.rt_user_action_list_;
    }
    clear_has_kind();
  }
}
inline ::RTUserActionList* Feature::release_rt_user_action_list() {
  // @@protoc_insertion_point(field_release:Feature.rt_user_action_list)
  if (_internal_has_rt_user_action_list()) {
    clear_has_kind();
    ::RTUserActionList* temp = _impl_.kind_.rt_user_action_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.rt_user_action_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RTUserActionList& Feature::_internal_rt_user_action_list() const {
  return _internal_has_rt_user_action_list()
      ? *_impl_.kind_.rt_user_action_list_
      : reinterpret_cast< ::RTUserActionList&>(::_RTUserActionList_default_instance_);
}
inline const ::RTUserActionList& Feature::rt_user_action_list() const {
  // @@protoc_insertion_point(field_get:Feature.rt_user_action_list)
  return _internal_rt_user_action_list();
}
inline ::RTUserActionList* Feature::unsafe_arena_release_rt_user_action_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.rt_user_action_list)
  if (_internal_has_rt_user_action_list()) {
    clear_has_kind();
    ::RTUserActionList* temp = _impl_.kind_.rt_user_action_list_;
    _impl_.kind_.rt_user_action_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_rt_user_action_list(::RTUserActionList* rt_user_action_list) {
  clear_kind();
  if (rt_user_action_list) {
    set_has_rt_user_action_list();
    _impl_.kind_.rt_user_action_list_ = rt_user_action_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.rt_user_action_list)
}
inline ::RTUserActionList* Feature::_internal_mutable_rt_user_action_list() {
  if (!_internal_has_rt_user_action_list()) {
    clear_kind();
    set_has_rt_user_action_list();
    _impl_.kind_.rt_user_action_list_ = CreateMaybeMessage< ::RTUserActionList >(GetArenaForAllocation());
  }
  return _impl_.kind_.rt_user_action_list_;
}
inline ::RTUserActionList* Feature::mutable_rt_user_action_list() {
  ::RTUserActionList* _msg = _internal_mutable_rt_user_action_list();
  // @@protoc_insertion_point(field_mutable:Feature.rt_user_action_list)
  return _msg;
}

// .ItemActionList item_action_list = 13;
inline bool Feature::_internal_has_item_action_list() const {
  return kind_case() == kItemActionList;
}
inline bool Feature::has_item_action_list() const {
  return _internal_has_item_action_list();
}
inline void Feature::set_has_item_action_list() {
  _impl_._oneof_case_[0] = kItemActionList;
}
inline void Feature::clear_item_action_list() {
  if (_internal_has_item_action_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.item_action_list_;
    }
    clear_has_kind();
  }
}
inline ::ItemActionList* Feature::release_item_action_list() {
  // @@protoc_insertion_point(field_release:Feature.item_action_list)
  if (_internal_has_item_action_list()) {
    clear_has_kind();
    ::ItemActionList* temp = _impl_.kind_.item_action_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.item_action_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ItemActionList& Feature::_internal_item_action_list() const {
  return _internal_has_item_action_list()
      ? *_impl_.kind_.item_action_list_
      : reinterpret_cast< ::ItemActionList&>(::_ItemActionList_default_instance_);
}
inline const ::ItemActionList& Feature::item_action_list() const {
  // @@protoc_insertion_point(field_get:Feature.item_action_list)
  return _internal_item_action_list();
}
inline ::ItemActionList* Feature::unsafe_arena_release_item_action_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Feature.item_action_list)
  if (_internal_has_item_action_list()) {
    clear_has_kind();
    ::ItemActionList* temp = _impl_.kind_.item_action_list_;
    _impl_.kind_.item_action_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Feature::unsafe_arena_set_allocated_item_action_list(::ItemActionList* item_action_list) {
  clear_kind();
  if (item_action_list) {
    set_has_item_action_list();
    _impl_.kind_.item_action_list_ = item_action_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Feature.item_action_list)
}
inline ::ItemActionList* Feature::_internal_mutable_item_action_list() {
  if (!_internal_has_item_action_list()) {
    clear_kind();
    set_has_item_action_list();
    _impl_.kind_.item_action_list_ = CreateMaybeMessage< ::ItemActionList >(GetArenaForAllocation());
  }
  return _impl_.kind_.item_action_list_;
}
inline ::ItemActionList* Feature::mutable_item_action_list() {
  ::ItemActionList* _msg = _internal_mutable_item_action_list();
  // @@protoc_insertion_point(field_mutable:Feature.item_action_list)
  return _msg;
}

// string str_value = 14;
inline bool Feature::_internal_has_str_value() const {
  return kind_case() == kStrValue;
}
inline bool Feature::has_str_value() const {
  return _internal_has_str_value();
}
inline void Feature::set_has_str_value() {
  _impl_._oneof_case_[0] = kStrValue;
}
inline void Feature::clear_str_value() {
  if (_internal_has_str_value()) {
    _impl_.kind_.str_value_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& Feature::str_value() const {
  // @@protoc_insertion_point(field_get:Feature.str_value)
  return _internal_str_value();
}
template <typename ArgT0, typename... ArgT>
inline void Feature::set_str_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_str_value()) {
    clear_kind();
    set_has_str_value();
    _impl_.kind_.str_value_.InitDefault();
  }
  _impl_.kind_.str_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Feature.str_value)
}
inline std::string* Feature::mutable_str_value() {
  std::string* _s = _internal_mutable_str_value();
  // @@protoc_insertion_point(field_mutable:Feature.str_value)
  return _s;
}
inline const std::string& Feature::_internal_str_value() const {
  if (_internal_has_str_value()) {
    return _impl_.kind_.str_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Feature::_internal_set_str_value(const std::string& value) {
  if (!_internal_has_str_value()) {
    clear_kind();
    set_has_str_value();
    _impl_.kind_.str_value_.InitDefault();
  }
  _impl_.kind_.str_value_.Set(value, GetArenaForAllocation());
}
inline std::string* Feature::_internal_mutable_str_value() {
  if (!_internal_has_str_value()) {
    clear_kind();
    set_has_str_value();
    _impl_.kind_.str_value_.InitDefault();
  }
  return _impl_.kind_.str_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* Feature::release_str_value() {
  // @@protoc_insertion_point(field_release:Feature.str_value)
  if (_internal_has_str_value()) {
    clear_has_kind();
    return _impl_.kind_.str_value_.Release();
  } else {
    return nullptr;
  }
}
inline void Feature::set_allocated_str_value(std::string* str_value) {
  if (has_kind()) {
    clear_kind();
  }
  if (str_value != nullptr) {
    set_has_str_value();
    _impl_.kind_.str_value_.InitAllocated(str_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:Feature.str_value)
}

// float float_value = 15;
inline bool Feature::_internal_has_float_value() const {
  return kind_case() == kFloatValue;
}
inline bool Feature::has_float_value() const {
  return _internal_has_float_value();
}
inline void Feature::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void Feature::clear_float_value() {
  if (_internal_has_float_value()) {
    _impl_.kind_.float_value_ = 0;
    clear_has_kind();
  }
}
inline float Feature::_internal_float_value() const {
  if (_internal_has_float_value()) {
    return _impl_.kind_.float_value_;
  }
  return 0;
}
inline void Feature::_internal_set_float_value(float value) {
  if (!_internal_has_float_value()) {
    clear_kind();
    set_has_float_value();
  }
  _impl_.kind_.float_value_ = value;
}
inline float Feature::float_value() const {
  // @@protoc_insertion_point(field_get:Feature.float_value)
  return _internal_float_value();
}
inline void Feature::set_float_value(float value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:Feature.float_value)
}

// int32 int_value = 16;
inline bool Feature::_internal_has_int_value() const {
  return kind_case() == kIntValue;
}
inline bool Feature::has_int_value() const {
  return _internal_has_int_value();
}
inline void Feature::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void Feature::clear_int_value() {
  if (_internal_has_int_value()) {
    _impl_.kind_.int_value_ = 0;
    clear_has_kind();
  }
}
inline int32_t Feature::_internal_int_value() const {
  if (_internal_has_int_value()) {
    return _impl_.kind_.int_value_;
  }
  return 0;
}
inline void Feature::_internal_set_int_value(int32_t value) {
  if (!_internal_has_int_value()) {
    clear_kind();
    set_has_int_value();
  }
  _impl_.kind_.int_value_ = value;
}
inline int32_t Feature::int_value() const {
  // @@protoc_insertion_point(field_get:Feature.int_value)
  return _internal_int_value();
}
inline void Feature::set_int_value(int32_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:Feature.int_value)
}

// int64 long_value = 17;
inline bool Feature::_internal_has_long_value() const {
  return kind_case() == kLongValue;
}
inline bool Feature::has_long_value() const {
  return _internal_has_long_value();
}
inline void Feature::set_has_long_value() {
  _impl_._oneof_case_[0] = kLongValue;
}
inline void Feature::clear_long_value() {
  if (_internal_has_long_value()) {
    _impl_.kind_.long_value_ = int64_t{0};
    clear_has_kind();
  }
}
inline int64_t Feature::_internal_long_value() const {
  if (_internal_has_long_value()) {
    return _impl_.kind_.long_value_;
  }
  return int64_t{0};
}
inline void Feature::_internal_set_long_value(int64_t value) {
  if (!_internal_has_long_value()) {
    clear_kind();
    set_has_long_value();
  }
  _impl_.kind_.long_value_ = value;
}
inline int64_t Feature::long_value() const {
  // @@protoc_insertion_point(field_get:Feature.long_value)
  return _internal_long_value();
}
inline void Feature::set_long_value(int64_t value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:Feature.long_value)
}

inline bool Feature::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Feature::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Feature::KindCase Feature::kind_case() const {
  return Feature::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserAction

// string item_id = 1;
inline void UserAction::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& UserAction::item_id() const {
  // @@protoc_insertion_point(field_get:UserAction.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserAction::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<const char *>(static_cast<const char *>(static_cast<ArgT0 &&>(arg0))), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserAction.item_id)
}
inline std::string* UserAction::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:UserAction.item_id)
  return _s;
}
inline const std::string& UserAction::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void UserAction::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAction::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAction::release_item_id() {
  // @@protoc_insertion_point(field_release:UserAction.item_id)
  return _impl_.item_id_.Release();
}
inline void UserAction::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserAction.item_id)
}

// int64 first_time = 2;
inline void UserAction::clear_first_time() {
  _impl_.first_time_ = int64_t{0};
}
inline int64_t UserAction::_internal_first_time() const {
  return _impl_.first_time_;
}
inline int64_t UserAction::first_time() const {
  // @@protoc_insertion_point(field_get:UserAction.first_time)
  return _internal_first_time();
}
inline void UserAction::_internal_set_first_time(int64_t value) {
  
  _impl_.first_time_ = value;
}
inline void UserAction::set_first_time(int64_t value) {
  _internal_set_first_time(value);
  // @@protoc_insertion_point(field_set:UserAction.first_time)
}

// int64 last_second_time = 3;
inline void UserAction::clear_last_second_time() {
  _impl_.last_second_time_ = int64_t{0};
}
inline int64_t UserAction::_internal_last_second_time() const {
  return _impl_.last_second_time_;
}
inline int64_t UserAction::last_second_time() const {
  // @@protoc_insertion_point(field_get:UserAction.last_second_time)
  return _internal_last_second_time();
}
inline void UserAction::_internal_set_last_second_time(int64_t value) {
  
  _impl_.last_second_time_ = value;
}
inline void UserAction::set_last_second_time(int64_t value) {
  _internal_set_last_second_time(value);
  // @@protoc_insertion_point(field_set:UserAction.last_second_time)
}

// int64 last_time = 4;
inline void UserAction::clear_last_time() {
  _impl_.last_time_ = int64_t{0};
}
inline int64_t UserAction::_internal_last_time() const {
  return _impl_.last_time_;
}
inline int64_t UserAction::last_time() const {
  // @@protoc_insertion_point(field_get:UserAction.last_time)
  return _internal_last_time();
}
inline void UserAction::_internal_set_last_time(int64_t value) {
  
  _impl_.last_time_ = value;
}
inline void UserAction::set_last_time(int64_t value) {
  _internal_set_last_time(value);
  // @@protoc_insertion_point(field_set:UserAction.last_time)
}

// int32 cnt = 5;
inline void UserAction::clear_cnt() {
  _impl_.cnt_ = 0;
}
inline int32_t UserAction::_internal_cnt() const {
  return _impl_.cnt_;
}
inline int32_t UserAction::cnt() const {
  // @@protoc_insertion_point(field_get:UserAction.cnt)
  return _internal_cnt();
}
inline void UserAction::_internal_set_cnt(int32_t value) {
  
  _impl_.cnt_ = value;
}
inline void UserAction::set_cnt(int32_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:UserAction.cnt)
}

// -------------------------------------------------------------------

// StrInt

// string key = 1;
inline void StrInt::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StrInt::key() const {
  // @@protoc_insertion_point(field_get:StrInt.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StrInt::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StrInt.key)
}
inline std::string* StrInt::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StrInt.key)
  return _s;
}
inline const std::string& StrInt::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StrInt::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StrInt::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StrInt::release_key() {
  // @@protoc_insertion_point(field_release:StrInt.key)
  return _impl_.key_.Release();
}
inline void StrInt::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StrInt.key)
}

// int32 value = 2;
inline void StrInt::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t StrInt::_internal_value() const {
  return _impl_.value_;
}
inline int32_t StrInt::value() const {
  // @@protoc_insertion_point(field_get:StrInt.value)
  return _internal_value();
}
inline void StrInt::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void StrInt::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:StrInt.value)
}

// -------------------------------------------------------------------

// StrFloat

// string key = 1;
inline void StrFloat::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StrFloat::key() const {
  // @@protoc_insertion_point(field_get:StrFloat.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StrFloat::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StrFloat.key)
}
inline std::string* StrFloat::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:StrFloat.key)
  return _s;
}
inline const std::string& StrFloat::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StrFloat::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StrFloat::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StrFloat::release_key() {
  // @@protoc_insertion_point(field_release:StrFloat.key)
  return _impl_.key_.Release();
}
inline void StrFloat::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StrFloat.key)
}

// float value = 2;
inline void StrFloat::clear_value() {
  _impl_.value_ = 0;
}
inline float StrFloat::_internal_value() const {
  return _impl_.value_;
}
inline float StrFloat::value() const {
  // @@protoc_insertion_point(field_get:StrFloat.value)
  return _internal_value();
}
inline void StrFloat::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void StrFloat::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:StrFloat.value)
}

// -------------------------------------------------------------------

// IntInt

// int32 key = 1;
inline void IntInt::clear_key() {
  _impl_.key_ = 0;
}
inline int32_t IntInt::_internal_key() const {
  return _impl_.key_;
}
inline int32_t IntInt::key() const {
  // @@protoc_insertion_point(field_get:IntInt.key)
  return _internal_key();
}
inline void IntInt::_internal_set_key(int32_t value) {
  
  _impl_.key_ = value;
}
inline void IntInt::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:IntInt.key)
}

// int32 value = 2;
inline void IntInt::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t IntInt::_internal_value() const {
  return _impl_.value_;
}
inline int32_t IntInt::value() const {
  // @@protoc_insertion_point(field_get:IntInt.value)
  return _internal_value();
}
inline void IntInt::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void IntInt::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IntInt.value)
}

// -------------------------------------------------------------------

// IntFloat

// int32 key = 1;
inline void IntFloat::clear_key() {
  _impl_.key_ = 0;
}
inline int32_t IntFloat::_internal_key() const {
  return _impl_.key_;
}
inline int32_t IntFloat::key() const {
  // @@protoc_insertion_point(field_get:IntFloat.key)
  return _internal_key();
}
inline void IntFloat::_internal_set_key(int32_t value) {
  
  _impl_.key_ = value;
}
inline void IntFloat::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:IntFloat.key)
}

// float value = 2;
inline void IntFloat::clear_value() {
  _impl_.value_ = 0;
}
inline float IntFloat::_internal_value() const {
  return _impl_.value_;
}
inline float IntFloat::value() const {
  // @@protoc_insertion_point(field_get:IntFloat.value)
  return _internal_value();
}
inline void IntFloat::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void IntFloat::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IntFloat.value)
}

// -------------------------------------------------------------------

// LongFloat

// int64 key = 1;
inline void LongFloat::clear_key() {
  _impl_.key_ = int64_t{0};
}
inline int64_t LongFloat::_internal_key() const {
  return _impl_.key_;
}
inline int64_t LongFloat::key() const {
  // @@protoc_insertion_point(field_get:LongFloat.key)
  return _internal_key();
}
inline void LongFloat::_internal_set_key(int64_t value) {
  
  _impl_.key_ = value;
}
inline void LongFloat::set_key(int64_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:LongFloat.key)
}

// float value = 2;
inline void LongFloat::clear_value() {
  _impl_.value_ = 0;
}
inline float LongFloat::_internal_value() const {
  return _impl_.value_;
}
inline float LongFloat::value() const {
  // @@protoc_insertion_point(field_get:LongFloat.value)
  return _internal_value();
}
inline void LongFloat::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void LongFloat::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:LongFloat.value)
}

// -------------------------------------------------------------------

// LongInt

// int64 key = 1;
inline void LongInt::clear_key() {
  _impl_.key_ = int64_t{0};
}
inline int64_t LongInt::_internal_key() const {
  return _impl_.key_;
}
inline int64_t LongInt::key() const {
  // @@protoc_insertion_point(field_get:LongInt.key)
  return _internal_key();
}
inline void LongInt::_internal_set_key(int64_t value) {
  
  _impl_.key_ = value;
}
inline void LongInt::set_key(int64_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:LongInt.key)
}

// int32 value = 2;
inline void LongInt::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t LongInt::_internal_value() const {
  return _impl_.value_;
}
inline int32_t LongInt::value() const {
  // @@protoc_insertion_point(field_get:LongInt.value)
  return _internal_value();
}
inline void LongInt::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void LongInt::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:LongInt.value)
}

// -------------------------------------------------------------------

// StrIntList

// repeated .StrInt value = 1;
inline int StrIntList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int StrIntList::value_size() const {
  return _internal_value_size();
}
inline void StrIntList::clear_value() {
  _impl_.value_.Clear();
}
inline ::StrInt* StrIntList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:StrIntList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrInt >*
StrIntList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:StrIntList.value)
  return &_impl_.value_;
}
inline const ::StrInt& StrIntList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::StrInt& StrIntList::value(int index) const {
  // @@protoc_insertion_point(field_get:StrIntList.value)
  return _internal_value(index);
}
inline ::StrInt* StrIntList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::StrInt* StrIntList::add_value() {
  ::StrInt* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:StrIntList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrInt >&
StrIntList::value() const {
  // @@protoc_insertion_point(field_list:StrIntList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// StrFloatList

// repeated .StrFloat value = 1;
inline int StrFloatList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int StrFloatList::value_size() const {
  return _internal_value_size();
}
inline void StrFloatList::clear_value() {
  _impl_.value_.Clear();
}
inline ::StrFloat* StrFloatList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:StrFloatList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrFloat >*
StrFloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:StrFloatList.value)
  return &_impl_.value_;
}
inline const ::StrFloat& StrFloatList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::StrFloat& StrFloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:StrFloatList.value)
  return _internal_value(index);
}
inline ::StrFloat* StrFloatList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::StrFloat* StrFloatList::add_value() {
  ::StrFloat* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:StrFloatList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StrFloat >&
StrFloatList::value() const {
  // @@protoc_insertion_point(field_list:StrFloatList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// IntFloatList

// repeated .IntFloat value = 1;
inline int IntFloatList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int IntFloatList::value_size() const {
  return _internal_value_size();
}
inline void IntFloatList::clear_value() {
  _impl_.value_.Clear();
}
inline ::IntFloat* IntFloatList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:IntFloatList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntFloat >*
IntFloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:IntFloatList.value)
  return &_impl_.value_;
}
inline const ::IntFloat& IntFloatList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::IntFloat& IntFloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:IntFloatList.value)
  return _internal_value(index);
}
inline ::IntFloat* IntFloatList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::IntFloat* IntFloatList::add_value() {
  ::IntFloat* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:IntFloatList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntFloat >&
IntFloatList::value() const {
  // @@protoc_insertion_point(field_list:IntFloatList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// IntIntList

// repeated .IntInt value = 1;
inline int IntIntList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int IntIntList::value_size() const {
  return _internal_value_size();
}
inline void IntIntList::clear_value() {
  _impl_.value_.Clear();
}
inline ::IntInt* IntIntList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:IntIntList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntInt >*
IntIntList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:IntIntList.value)
  return &_impl_.value_;
}
inline const ::IntInt& IntIntList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::IntInt& IntIntList::value(int index) const {
  // @@protoc_insertion_point(field_get:IntIntList.value)
  return _internal_value(index);
}
inline ::IntInt* IntIntList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::IntInt* IntIntList::add_value() {
  ::IntInt* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:IntIntList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntInt >&
IntIntList::value() const {
  // @@protoc_insertion_point(field_list:IntIntList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// LongIntList

// repeated .LongInt value = 1;
inline int LongIntList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int LongIntList::value_size() const {
  return _internal_value_size();
}
inline void LongIntList::clear_value() {
  _impl_.value_.Clear();
}
inline ::LongInt* LongIntList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:LongIntList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongInt >*
LongIntList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:LongIntList.value)
  return &_impl_.value_;
}
inline const ::LongInt& LongIntList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::LongInt& LongIntList::value(int index) const {
  // @@protoc_insertion_point(field_get:LongIntList.value)
  return _internal_value(index);
}
inline ::LongInt* LongIntList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::LongInt* LongIntList::add_value() {
  ::LongInt* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:LongIntList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongInt >&
LongIntList::value() const {
  // @@protoc_insertion_point(field_list:LongIntList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// LongFloatList

// repeated .LongFloat value = 1;
inline int LongFloatList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int LongFloatList::value_size() const {
  return _internal_value_size();
}
inline void LongFloatList::clear_value() {
  _impl_.value_.Clear();
}
inline ::LongFloat* LongFloatList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:LongFloatList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongFloat >*
LongFloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:LongFloatList.value)
  return &_impl_.value_;
}
inline const ::LongFloat& LongFloatList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::LongFloat& LongFloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:LongFloatList.value)
  return _internal_value(index);
}
inline ::LongFloat* LongFloatList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::LongFloat* LongFloatList::add_value() {
  ::LongFloat* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:LongFloatList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LongFloat >&
LongFloatList::value() const {
  // @@protoc_insertion_point(field_list:LongFloatList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// FloatList

// repeated float value = 1 [packed = true];
inline int FloatList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int FloatList::value_size() const {
  return _internal_value_size();
}
inline void FloatList::clear_value() {
  _impl_.value_.Clear();
}
inline float FloatList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline float FloatList::value(int index) const {
  // @@protoc_insertion_point(field_get:FloatList.value)
  return _internal_value(index);
}
inline void FloatList::set_value(int index, float value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:FloatList.value)
}
inline void FloatList::_internal_add_value(float value) {
  _impl_.value_.Add(value);
}
inline void FloatList::add_value(float value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:FloatList.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatList::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatList::value() const {
  // @@protoc_insertion_point(field_list:FloatList.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatList::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:FloatList.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// LongList

// repeated int64 value = 1 [packed = true];
inline int LongList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int LongList::value_size() const {
  return _internal_value_size();
}
inline void LongList::clear_value() {
  _impl_.value_.Clear();
}
inline int64_t LongList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline int64_t LongList::value(int index) const {
  // @@protoc_insertion_point(field_get:LongList.value)
  return _internal_value(index);
}
inline void LongList::set_value(int index, int64_t value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:LongList.value)
}
inline void LongList::_internal_add_value(int64_t value) {
  _impl_.value_.Add(value);
}
inline void LongList::add_value(int64_t value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:LongList.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
LongList::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
LongList::value() const {
  // @@protoc_insertion_point(field_list:LongList.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
LongList::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
LongList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:LongList.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// IntList

// repeated int32 value = 1 [packed = true];
inline int IntList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int IntList::value_size() const {
  return _internal_value_size();
}
inline void IntList::clear_value() {
  _impl_.value_.Clear();
}
inline int32_t IntList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline int32_t IntList::value(int index) const {
  // @@protoc_insertion_point(field_get:IntList.value)
  return _internal_value(index);
}
inline void IntList::set_value(int index, int32_t value) {
  _impl_.value_.Set(index, value);
  // @@protoc_insertion_point(field_set:IntList.value)
}
inline void IntList::_internal_add_value(int32_t value) {
  _impl_.value_.Add(value);
}
inline void IntList::add_value(int32_t value) {
  _internal_add_value(value);
  // @@protoc_insertion_point(field_add:IntList.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntList::_internal_value() const {
  return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntList::value() const {
  // @@protoc_insertion_point(field_list:IntList.value)
  return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntList::_internal_mutable_value() {
  return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:IntList.value)
  return _internal_mutable_value();
}

// -------------------------------------------------------------------

// StrList

// repeated string value = 1;
inline int StrList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int StrList::value_size() const {
  return _internal_value_size();
}
inline void StrList::clear_value() {
  _impl_.value_.Clear();
}
inline std::string* StrList::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:StrList.value)
  return _s;
}
inline const std::string& StrList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const std::string& StrList::value(int index) const {
  // @@protoc_insertion_point(field_get:StrList.value)
  return _internal_value(index);
}
inline std::string* StrList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:StrList.value)
  return _impl_.value_.Mutable(index);
}
inline void StrList::set_value(int index, const std::string& value) {
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:StrList.value)
}
inline void StrList::set_value(int index, std::string&& value) {
  _impl_.value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:StrList.value)
}
inline void StrList::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:StrList.value)
}
inline void StrList::set_value(int index, const char* value, size_t size) {
  _impl_.value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StrList.value)
}
inline std::string* StrList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline void StrList::add_value(const std::string& value) {
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:StrList.value)
}
inline void StrList::add_value(std::string&& value) {
  _impl_.value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:StrList.value)
}
inline void StrList::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:StrList.value)
}
inline void StrList::add_value(const char* value, size_t size) {
  _impl_.value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:StrList.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StrList::value() const {
  // @@protoc_insertion_point(field_list:StrList.value)
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StrList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:StrList.value)
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// UserActionList

// repeated .UserAction value = 1;
inline int UserActionList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int UserActionList::value_size() const {
  return _internal_value_size();
}
inline void UserActionList::clear_value() {
  _impl_.value_.Clear();
}
inline ::UserAction* UserActionList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:UserActionList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserAction >*
UserActionList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:UserActionList.value)
  return &_impl_.value_;
}
inline const ::UserAction& UserActionList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::UserAction& UserActionList::value(int index) const {
  // @@protoc_insertion_point(field_get:UserActionList.value)
  return _internal_value(index);
}
inline ::UserAction* UserActionList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::UserAction* UserActionList::add_value() {
  ::UserAction* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:UserActionList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserAction >&
UserActionList::value() const {
  // @@protoc_insertion_point(field_list:UserActionList.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// Item

// string item_id = 1;
inline void Item::clear_item_id() {
  _impl_.item_id_.ClearToEmpty();
}
inline std::string const Item::item_id() const {
  // @@protoc_insertion_point(field_get:Item.item_id)
  return _internal_item_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_item_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.item_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Item.item_id)
}
inline std::string* Item::mutable_item_id() {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:Item.item_id)
  return _s;
}
inline const std::string& Item::_internal_item_id() const {
  return _impl_.item_id_.Get();
}
inline void Item::_internal_set_item_id(const std::string& value) {
  
  _impl_.item_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_item_id() {
  
  return _impl_.item_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_item_id() {
  // @@protoc_insertion_point(field_release:Item.item_id)
  return _impl_.item_id_.Release();
}
inline void Item::set_allocated_item_id(std::string* item_id) {
  if (item_id != nullptr) {
    
  } else {
    
  }
  _impl_.item_id_.SetAllocated(item_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.item_id_.IsDefault()) {
    _impl_.item_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Item.item_id)
}

// string collection_id = 2;
inline void Item::clear_collection_id() {
  _impl_.collection_id_.ClearToEmpty();
}
inline const std::string& Item::collection_id() const {
  // @@protoc_insertion_point(field_get:Item.collection_id)
  return _internal_collection_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Item::set_collection_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.collection_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Item.collection_id)
}
inline std::string* Item::mutable_collection_id() {
  std::string* _s = _internal_mutable_collection_id();
  // @@protoc_insertion_point(field_mutable:Item.collection_id)
  return _s;
}
inline const std::string& Item::_internal_collection_id() const {
  return _impl_.collection_id_.Get();
}
inline void Item::_internal_set_collection_id(const std::string& value) {
  
  _impl_.collection_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Item::_internal_mutable_collection_id() {
  
  return _impl_.collection_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Item::release_collection_id() {
  // @@protoc_insertion_point(field_release:Item.collection_id)
  return _impl_.collection_id_.Release();
}
inline void Item::set_allocated_collection_id(std::string* collection_id) {
  if (collection_id != nullptr) {
    
  } else {
    
  }
  _impl_.collection_id_.SetAllocated(collection_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.collection_id_.IsDefault()) {
    _impl_.collection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Item.collection_id)
}

// int64 store_id = 3;
inline void Item::clear_store_id() {
  _impl_.store_id_ = int64_t{0};
}
inline int64_t Item::_internal_store_id() const {
  return _impl_.store_id_;
}
inline int64_t Item::store_id() const {
  // @@protoc_insertion_point(field_get:Item.store_id)
  return _internal_store_id();
}
inline void Item::_internal_set_store_id(int64_t value) {
  
  _impl_.store_id_ = value;
}
inline void Item::set_store_id(int64_t value) {
  _internal_set_store_id(value);
  // @@protoc_insertion_point(field_set:Item.store_id)
}

// int64 first_time = 4;
inline void Item::clear_first_time() {
  _impl_.first_time_ = int64_t{0};
}
inline int64_t Item::_internal_first_time() const {
  return _impl_.first_time_;
}
inline int64_t Item::first_time() const {
  // @@protoc_insertion_point(field_get:Item.first_time)
  return _internal_first_time();
}
inline void Item::_internal_set_first_time(int64_t value) {
  
  _impl_.first_time_ = value;
}
inline void Item::set_first_time(int64_t value) {
  _internal_set_first_time(value);
  // @@protoc_insertion_point(field_set:Item.first_time)
}

// int64 last_second_time = 5;
inline void Item::clear_last_second_time() {
  _impl_.last_second_time_ = int64_t{0};
}
inline int64_t Item::_internal_last_second_time() const {
  return _impl_.last_second_time_;
}
inline int64_t Item::last_second_time() const {
  // @@protoc_insertion_point(field_get:Item.last_second_time)
  return _internal_last_second_time();
}
inline void Item::_internal_set_last_second_time(int64_t value) {
  
  _impl_.last_second_time_ = value;
}
inline void Item::set_last_second_time(int64_t value) {
  _internal_set_last_second_time(value);
  // @@protoc_insertion_point(field_set:Item.last_second_time)
}

// int64 last_time = 6;
inline void Item::clear_last_time() {
  _impl_.last_time_ = int64_t{0};
}
inline int64_t Item::_internal_last_time() const {
  return _impl_.last_time_;
}
inline int64_t Item::last_time() const {
  // @@protoc_insertion_point(field_get:Item.last_time)
  return _internal_last_time();
}
inline void Item::_internal_set_last_time(int64_t value) {
  
  _impl_.last_time_ = value;
}
inline void Item::set_last_time(int64_t value) {
  _internal_set_last_time(value);
  // @@protoc_insertion_point(field_set:Item.last_time)
}

// int64 cnt = 7;
inline void Item::clear_cnt() {
  _impl_.cnt_ = int64_t{0};
}
inline int64_t Item::_internal_cnt() const {
  return _impl_.cnt_;
}
inline int64_t Item::cnt() const {
  // @@protoc_insertion_point(field_get:Item.cnt)
  return _internal_cnt();
}
inline void Item::_internal_set_cnt(int64_t value) {
  
  _impl_.cnt_ = value;
}
inline void Item::set_cnt(int64_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:Item.cnt)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RTUserActionList

// map<string, .Item> items = 1;
inline int RTUserActionList::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RTUserActionList::items_size() const {
  return _internal_items_size();
}
inline void RTUserActionList::clear_items() {
  _impl_.items_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >&
RTUserActionList::_internal_items() const {
  return _impl_.items_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >&
RTUserActionList::items() const {
  // @@protoc_insertion_point(field_map:RTUserActionList.items)
  return _internal_items();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >*
RTUserActionList::_internal_mutable_items() {
  return _impl_.items_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Item >*
RTUserActionList::mutable_items() {
  // @@protoc_insertion_point(field_mutable_map:RTUserActionList.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// ItemAction

// string event = 1;
inline void ItemAction::clear_event() {
  _impl_.event_.ClearToEmpty();
}
inline const std::string& ItemAction::event() const {
  // @@protoc_insertion_point(field_get:ItemAction.event)
  return _internal_event();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemAction::set_event(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ItemAction.event)
}
inline std::string* ItemAction::mutable_event() {
  std::string* _s = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:ItemAction.event)
  return _s;
}
inline const std::string& ItemAction::_internal_event() const {
  return _impl_.event_.Get();
}
inline void ItemAction::_internal_set_event(const std::string& value) {
  
  _impl_.event_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemAction::_internal_mutable_event() {
  
  return _impl_.event_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemAction::release_event() {
  // @@protoc_insertion_point(field_release:ItemAction.event)
  return _impl_.event_.Release();
}
inline void ItemAction::set_allocated_event(std::string* event) {
  if (event != nullptr) {
    
  } else {
    
  }
  _impl_.event_.SetAllocated(event, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_.IsDefault()) {
    _impl_.event_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ItemAction.event)
}

// string context = 2;
inline void ItemAction::clear_context() {
  _impl_.context_.ClearToEmpty();
}
inline const std::string& ItemAction::context() const {
  // @@protoc_insertion_point(field_get:ItemAction.context)
  return _internal_context();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemAction::set_context(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ItemAction.context)
}
inline std::string* ItemAction::mutable_context() {
  std::string* _s = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:ItemAction.context)
  return _s;
}
inline const std::string& ItemAction::_internal_context() const {
  return _impl_.context_.Get();
}
inline void ItemAction::_internal_set_context(const std::string& value) {
  
  _impl_.context_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemAction::_internal_mutable_context() {
  
  return _impl_.context_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemAction::release_context() {
  // @@protoc_insertion_point(field_release:ItemAction.context)
  return _impl_.context_.Release();
}
inline void ItemAction::set_allocated_context(std::string* context) {
  if (context != nullptr) {
    
  } else {
    
  }
  _impl_.context_.SetAllocated(context, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_.IsDefault()) {
    _impl_.context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ItemAction.context)
}

// int32 cnt = 3;
inline void ItemAction::clear_cnt() {
  _impl_.cnt_ = 0;
}
inline int32_t ItemAction::_internal_cnt() const {
  return _impl_.cnt_;
}
inline int32_t ItemAction::cnt() const {
  // @@protoc_insertion_point(field_get:ItemAction.cnt)
  return _internal_cnt();
}
inline void ItemAction::_internal_set_cnt(int32_t value) {
  
  _impl_.cnt_ = value;
}
inline void ItemAction::set_cnt(int32_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:ItemAction.cnt)
}

// int32 dist_cnt = 4;
inline void ItemAction::clear_dist_cnt() {
  _impl_.dist_cnt_ = 0;
}
inline int32_t ItemAction::_internal_dist_cnt() const {
  return _impl_.dist_cnt_;
}
inline int32_t ItemAction::dist_cnt() const {
  // @@protoc_insertion_point(field_get:ItemAction.dist_cnt)
  return _internal_dist_cnt();
}
inline void ItemAction::_internal_set_dist_cnt(int32_t value) {
  
  _impl_.dist_cnt_ = value;
}
inline void ItemAction::set_dist_cnt(int32_t value) {
  _internal_set_dist_cnt(value);
  // @@protoc_insertion_point(field_set:ItemAction.dist_cnt)
}

// int32 click_cnt = 5;
inline void ItemAction::clear_click_cnt() {
  _impl_.click_cnt_ = 0;
}
inline int32_t ItemAction::_internal_click_cnt() const {
  return _impl_.click_cnt_;
}
inline int32_t ItemAction::click_cnt() const {
  // @@protoc_insertion_point(field_get:ItemAction.click_cnt)
  return _internal_click_cnt();
}
inline void ItemAction::_internal_set_click_cnt(int32_t value) {
  
  _impl_.click_cnt_ = value;
}
inline void ItemAction::set_click_cnt(int32_t value) {
  _internal_set_click_cnt(value);
  // @@protoc_insertion_point(field_set:ItemAction.click_cnt)
}

// int32 buy_cnt = 6;
inline void ItemAction::clear_buy_cnt() {
  _impl_.buy_cnt_ = 0;
}
inline int32_t ItemAction::_internal_buy_cnt() const {
  return _impl_.buy_cnt_;
}
inline int32_t ItemAction::buy_cnt() const {
  // @@protoc_insertion_point(field_get:ItemAction.buy_cnt)
  return _internal_buy_cnt();
}
inline void ItemAction::_internal_set_buy_cnt(int32_t value) {
  
  _impl_.buy_cnt_ = value;
}
inline void ItemAction::set_buy_cnt(int32_t value) {
  _internal_set_buy_cnt(value);
  // @@protoc_insertion_point(field_set:ItemAction.buy_cnt)
}

// string date = 7;
inline void ItemAction::clear_date() {
  _impl_.date_.ClearToEmpty();
}
inline const std::string& ItemAction::date() const {
  // @@protoc_insertion_point(field_get:ItemAction.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemAction::set_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ItemAction.date)
}
inline std::string* ItemAction::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:ItemAction.date)
  return _s;
}
inline const std::string& ItemAction::_internal_date() const {
  return _impl_.date_.Get();
}
inline void ItemAction::_internal_set_date(const std::string& value) {
  
  _impl_.date_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemAction::_internal_mutable_date() {
  
  return _impl_.date_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemAction::release_date() {
  // @@protoc_insertion_point(field_release:ItemAction.date)
  return _impl_.date_.Release();
}
inline void ItemAction::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  _impl_.date_.SetAllocated(date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_.IsDefault()) {
    _impl_.date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ItemAction.date)
}

// -------------------------------------------------------------------

// ItemActionList

// repeated .ItemAction value = 1;
inline int ItemActionList::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int ItemActionList::value_size() const {
  return _internal_value_size();
}
inline void ItemActionList::clear_value() {
  _impl_.value_.Clear();
}
inline ::ItemAction* ItemActionList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:ItemActionList.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemAction >*
ItemActionList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:ItemActionList.value)
  return &_impl_.value_;
}
inline const ::ItemAction& ItemActionList::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::ItemAction& ItemActionList::value(int index) const {
  // @@protoc_insertion_point(field_get:ItemActionList.value)
  return _internal_value(index);
}
inline ::ItemAction* ItemActionList::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::ItemAction* ItemActionList::add_value() {
  ::ItemAction* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:ItemActionList.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemAction >&
ItemActionList::value() const {
  // @@protoc_insertion_point(field_list:ItemActionList.value)
  return _impl_.value_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_features_2eproto
